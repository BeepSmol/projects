<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sandbox Engine</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Cannon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #game-canvas { display: block; width: 100vw; height: 100vh; position: absolute; z-index: 1; }
        
        /* UI Layers */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 10; }
        .interactive { pointer-events: auto; }
        .hidden { display: none !important; }
        
        /* Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: white; border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; transition: all 0.1s ease; mix-blend-mode: difference;
        }
        #crosshair.active { width: 12px; height: 12px; background: transparent; border: 2px solid #48bb78; }
        
        /* Scrollbars */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        .code-editor { font-family: 'Courier New', monospace; tab-size: 4; white-space: pre; overflow-wrap: normal; overflow-x: auto; }
    </style>
</head>
<body>

    <!-- WebGL Canvas -->
    <canvas id="game-canvas"></canvas>

    <!-- UI Overlay -->
    <div id="ui-layer" class="ui-layer">
        
        <!-- Crosshair -->
        <div id="crosshair" class="hidden"></div>

        <!-- HUD -->
        <div id="hud" class="hidden absolute bottom-6 right-8 text-right drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)]">
            <h1 class="text-4xl font-extrabold italic text-blue-400 tracking-wider" id="hud-tool">PHYSGUN</h1>
            <p class="text-sm text-gray-200 font-semibold" id="hud-desc">LMB: Grab | Scroll: Distance | RMB: Freeze | E: Unfreeze</p>
            <div class="mt-3 flex justify-end gap-2 text-xs font-bold text-gray-400">
                <span class="bg-gray-800 bg-opacity-70 px-2 py-1 rounded border border-gray-600">1: Physgun</span>
                <span class="bg-gray-800 bg-opacity-70 px-2 py-1 rounded border border-gray-600">2: Portal Gun</span>
                <span class="bg-gray-800 bg-opacity-70 px-2 py-1 rounded border border-gray-600">Esc: Menu</span>
            </div>
        </div>

        <!-- Launch Screen -->
        <div id="launch-screen" class="interactive absolute inset-0 bg-gray-900 bg-opacity-95 flex items-center justify-center z-50 backdrop-blur-sm">
            <div class="bg-gray-800 p-8 rounded-2xl shadow-2xl w-full max-w-3xl text-white border border-gray-700">
                <div class="text-center mb-8">
                    <h1 class="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-blue-400 via-emerald-400 to-purple-500 mb-2">3D Physics engine</h1>
                    <p class="text-gray-400 font-medium">By BeepSmol (PLAY IN FULLSCREEN (F11/Fn+F11))</p>
                </div>
                
                <div class="grid grid-cols-2 gap-6">
                    <!-- Blank Canvas -->
                    <div class="bg-gray-900 p-6 rounded-xl border border-gray-700 hover:border-blue-500 transition shadow-inner">
                        <div class="text-3xl mb-3">üü©</div>
                        <h2 class="text-2xl font-bold mb-2">Blank Canvas</h2>
                        <p class="text-sm text-gray-400 mb-6 h-10">An infinite flatgrass world. Build and experiment from scratch.</p>
                        <div class="flex flex-col space-y-2">
                            <button class="w-full py-2 bg-blue-600 hover:bg-blue-500 rounded font-bold transition" onclick="WG.launch('blank', 'main')">Play</button>
                            <button class="w-full py-2 bg-emerald-600 hover:bg-emerald-500 rounded font-bold transition" onclick="WG.launch('blank', 'sandbox')">Sandbox (Edit Mode)</button>
                        </div>
                    </div>

                    <!-- Premade Game -->
                    <div class="bg-gray-900 p-6 rounded-xl border border-gray-700 hover:border-emerald-500 transition shadow-inner">
                        <div class="text-3xl mb-3">üèóÔ∏è</div>
                        <h2 class="text-2xl font-bold mb-2">Physics Playground</h2>
                        <p class="text-sm text-gray-400 mb-6 h-10">A pre-built environment with ramps, walls, and dynamic objects.</p>
                        <div class="flex flex-col space-y-2">
                            <button class="w-full py-2 bg-blue-600 hover:bg-blue-500 rounded font-bold transition" onclick="WG.launch('premade', 'main')">Play</button>
                            <button class="w-full py-2 bg-emerald-600 hover:bg-emerald-500 rounded font-bold transition" onclick="WG.launch('premade', 'sandbox')">Sandbox (Edit Mode)</button>
                        </div>
                    </div>
                </div>

                <div class="mt-8 pt-6 border-t border-gray-700 flex justify-between items-center">
                    <button class="text-sm bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded font-semibold transition" onclick="WG.Data.importFile()">üìÇ Import World (.json)</button>
                    <span class="text-xs text-gray-500 font-mono">v0.5.7</span>
                </div>
            </div>
        </div>

        <!-- Q-Menu -->
        <div id="q-menu" class="interactive hidden absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center z-40 backdrop-blur-md">
            <div class="bg-gray-800 w-[80%] h-[80%] rounded-2xl shadow-2xl flex overflow-hidden border border-gray-600">
                <!-- Sidebar -->
                <div class="w-64 bg-gray-900 p-5 flex flex-col border-r border-gray-700">
                    <h2 class="text-white text-2xl font-black mb-6 tracking-wide">SPAWN MENU</h2>
                    <div class="flex-1 space-y-2">
                        <button class="w-full text-left px-4 py-3 bg-gray-800 text-gray-200 rounded-lg hover:bg-gray-700 hover:text-white font-semibold transition" onclick="WG.UI.switchTab('primitives')">üì¶ Primitives</button>
                        <button class="w-full text-left px-4 py-3 bg-gray-800 text-gray-200 rounded-lg hover:bg-gray-700 hover:text-white font-semibold transition" onclick="WG.UI.switchTab('custom')">üß© Custom Models</button>
                    </div>
                    <div class="space-y-3 pt-4 border-t border-gray-700">
                        <button class="w-full py-3 bg-purple-600 hover:bg-purple-500 text-white rounded-lg font-bold shadow-lg transition" onclick="WG.UI.openModelMaker()">üé® Model Maker</button>
                        <button class="w-full py-3 bg-indigo-600 hover:bg-indigo-500 text-white rounded-lg font-bold shadow-lg transition" onclick="WG.UI.openModCreator()">‚öôÔ∏è Mod API</button>
                    </div>
                    <div class="space-y-2 pt-4 border-t border-gray-700 mt-4">
                        <button class="w-full py-2 bg-gray-700 hover:bg-gray-600 text-white rounded font-semibold text-sm transition" onclick="WG.Data.saveSlot()">üíæ Save World State</button>
                        <button class="w-full py-2 bg-gray-700 hover:bg-gray-600 text-white rounded font-semibold text-sm transition" onclick="WG.Data.exportFile()">üì¶ Export to File</button>
                    </div>
                </div>
                <!-- Content Area -->
                <div class="flex-1 p-8 overflow-y-auto bg-gray-800" id="q-content">
                    <!-- Injected via JS -->
                </div>
            </div>
        </div>

        <!-- Model Maker Modal -->
        <div id="model-maker" class="interactive hidden absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
            <div class="bg-gray-800 w-[700px] h-[500px] rounded-xl shadow-2xl flex flex-col overflow-hidden border border-gray-600">
                <div class="p-4 bg-gray-900 border-b border-gray-700 flex justify-between items-center">
                    <h2 class="text-white text-xl font-bold">Model Maker</h2>
                    <button class="text-gray-400 hover:text-white text-2xl leading-none" onclick="WG.UI.closeModals()">&times;</button>
                </div>
                <div class="p-5 flex-1 flex flex-col">
                    <div class="flex space-x-3 mb-4">
                        <input type="text" id="mm-name" placeholder="Prop Name (e.g. Table)" class="bg-gray-900 text-white px-4 py-2 rounded-lg border border-gray-700 flex-1 focus:outline-none focus:border-purple-500">
                        <button class="bg-purple-600 hover:bg-purple-500 text-white px-5 py-2 rounded-lg font-bold transition" onclick="WG.UI.MM.addPart()">+ Add Part</button>
                    </div>
                    <!-- Parts List -->
                    <div class="flex-1 overflow-y-auto bg-gray-900 rounded-lg border border-gray-700 p-3 space-y-3" id="mm-parts"></div>
                </div>
                <div class="p-4 bg-gray-900 border-t border-gray-700 flex justify-end">
                    <button class="bg-emerald-600 hover:bg-emerald-500 text-white px-8 py-2 rounded-lg font-bold transition shadow-lg" onclick="WG.UI.MM.save()">Save to Library</button>
                </div>
            </div>
        </div>

        <!-- Mod Creator Modal -->
        <div id="mod-creator" class="interactive hidden absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
            <div class="bg-gray-800 w-[800px] h-[600px] rounded-xl shadow-2xl flex flex-col overflow-hidden border border-gray-600">
                <div class="p-4 bg-gray-900 border-b border-gray-700 flex justify-between items-center">
                    <h2 class="text-white text-xl font-bold">Mod API Editor</h2>
                    <button class="text-gray-400 hover:text-white text-2xl leading-none" onclick="WG.UI.closeModals()">&times;</button>
                </div>
                <div class="p-4 flex-1 flex flex-col bg-[#1e1e1e]">
                    <div class="text-xs text-gray-400 mb-2 font-mono">
                        Available: <span class="text-blue-400">API.spawn(type, x, y, z, {color, mass, size})</span> | <span class="text-blue-400">API.onTick(fn)</span> | <span class="text-blue-400">API.setGravity(y)</span>
                    </div>
                    <textarea id="mod-code" class="code-editor flex-1 bg-transparent text-green-400 p-2 border border-gray-700 rounded focus:outline-none focus:border-indigo-500 resize-none" spellcheck="false">
// Example: Low Gravity + Spawn Loop
API.setGravity(-2); // Moon Gravity

let timer = 0;
API.onTick((delta) => {
    timer += delta;
    if(timer > 5) {
        // Spawn a random box every 5 seconds above the origin
        let size = [Math.random()*2+1, Math.random()*2+1, Math.random()*2+1];
        let color = Math.floor(Math.random()*16777215);
        API.spawn('box', 0, 20, 0, { size: size, color: color, mass: 2 });
        timer = 0;
    }
});
                    </textarea>
                </div>
                <div class="p-4 bg-gray-900 border-t border-gray-700 flex justify-end space-x-3">
                    <button class="bg-red-600 hover:bg-red-500 text-white px-6 py-2 rounded-lg font-bold transition" onclick="WG.Mod.clear()">Clear Hooks</button>
                    <button class="bg-indigo-600 hover:bg-indigo-500 text-white px-6 py-2 rounded-lg font-bold transition shadow-lg" onclick="WG.Mod.execute()">Inject Script</button>
                </div>
            </div>
        </div>

    </div>

<script>
/**
 * WebGMOD - Unified Global Namespace Architecture
 */
window.WG = {
    mode: 'sandbox',
    objects: [],
    customModels: {},
    
    // Systems
    scene: null, camera: null, renderer: null, world: null, clock: null,
    materials: {},
    
    // State
    isRunning: false,
    keys: { w: false, a: false, s: false, d: false, space: false, q: false, e: false },
    mouse: { left: false, right: false },

    launch: async function(template, mode) {
        this.mode = mode;
        document.getElementById('launch-screen').classList.add('hidden');
        document.getElementById('crosshair').classList.remove('hidden');
        if(mode === 'sandbox') document.getElementById('hud').classList.remove('hidden');

        await this.Data.initDB();
        this.initEngine();
        this.Player.init();
        this.Tools.init();
        this.Portals.init();
        this.UI.init();

        // Load custom models
        await this.Data.loadCustomModels();

        if (template === 'premade') this.buildPremade();
        else this.buildBlank();

        this.isRunning = true;
        this.animate();

        // Try to lock pointer
        this.lockPointer();
    },

    initEngine: function() {
        const canvas = document.getElementById('game-canvas');
        
        // THREE.JS SETUP
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x87ceeb);
        this.scene.fog = new THREE.Fog(0x87ceeb, 20, 300);

        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        this.renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // LIGHTS
        const ambient = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(ambient);
        
        const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
        hemi.position.set(0, 200, 0);
        this.scene.add(hemi);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(100, 200, 50);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 100; dirLight.shadow.camera.bottom = -100;
        dirLight.shadow.camera.left = -100; dirLight.shadow.camera.right = 100;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        this.scene.add(dirLight);

        // CANNON.JS SETUP
        this.world = new CANNON.World();
        this.world.gravity.set(0, -15, 0);
        this.world.broadphase = new CANNON.NaiveBroadphase();
        this.world.solver.iterations = 20; // High iterations for stability
        
        // Materials
        this.materials.standard = new CANNON.Material("standard");
        this.materials.player = new CANNON.Material("player");
        
        // Player material has 0 friction so we don't stick to walls
        const playerContactMat = new CANNON.ContactMaterial(
            this.materials.standard, this.materials.player, 
            { friction: 0.0, restitution: 0.0 }
        );
        const stdContactMat = new CANNON.ContactMaterial(
            this.materials.standard, this.materials.standard, 
            { friction: 0.3, restitution: 0.2 }
        );
        
        this.world.addContactMaterial(playerContactMat);
        this.world.addContactMaterial(stdContactMat);

        this.clock = new THREE.Clock();

        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
    },

    clearWorld: function() {
        this.objects.forEach(obj => {
            if(obj.mesh) this.scene.remove(obj.mesh);
            if(obj.body) this.world.remove(obj.body);
        });
        this.objects = [];
        this.Portals.clear();
        this.Mod.clear();
    },

    buildBlank: function() {
        this.clearWorld();
        // Ground
        const groundGeo = new THREE.PlaneGeometry(500, 500);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x3d5a40, roughness: 0.8 });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        this.scene.add(groundMesh);

        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, material: this.materials.standard });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
        this.world.addBody(groundBody);

        // Add to objects array so raycaster finds it
        this.objects.push({ type: 'static', mesh: groundMesh, body: groundBody });

        // Grid
        const grid = new THREE.GridHelper(500, 100, 0x000000, 0x000000);
        grid.material.opacity = 0.2; grid.material.transparent = true;
        this.scene.add(grid);
    },

    buildPremade: function() {
        this.buildBlank();
        
        // Generate some walls
        this.spawnPrimitive('box', 0, 10, -50, { size: [100, 20, 2], isStatic: true, color: '#888888' });
        this.spawnPrimitive('box', 0, 10, 50, { size: [100, 20, 2], isStatic: true, color: '#888888' });
        this.spawnPrimitive('box', -50, 10, 0, { size: [2, 20, 100], isStatic: true, color: '#888888' });
        this.spawnPrimitive('box', 50, 10, 0, { size: [2, 20, 100], isStatic: true, color: '#888888' });

        // A ramp
        let ramp = this.spawnPrimitive('box', 0, 4, -20, { size: [20, 1, 30], isStatic: true, color: '#a0522d' });
        ramp.body.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), 0.3);

        // Dynamic Props
        this.spawnPrimitive('box', -10, 5, -10, { size: [2,2,2], color: '#ff3333', mass: 5 });
        this.spawnPrimitive('box', -10, 8, -10, { size: [2,2,2], color: '#33ff33', mass: 5 });
        this.spawnPrimitive('sphere', 10, 5, -10, { size: [3], color: '#3333ff', mass: 10 });
        this.spawnPrimitive('cylinder', 15, 5, 0, { size: [2, 4], color: '#ffff33', mass: 8 });
    },

    spawnPrimitive: function(type, x, y, z, opts = {}) {
        let size = opts.size || [2, 2, 2];
        let color = opts.color || Math.random() * 0xffffff;
        let mass = opts.isStatic ? 0 : (opts.mass !== undefined ? opts.mass : 5);

        let geo, shape;
        if(type === 'box') {
            geo = new THREE.BoxGeometry(size[0], size[1], size[2]);
            shape = new CANNON.Box(new CANNON.Vec3(size[0]/2, size[1]/2, size[2]/2));
        } else if (type === 'sphere') {
            geo = new THREE.SphereGeometry(size[0]/2, 32, 32);
            shape = new CANNON.Sphere(size[0]/2);
        } else if (type === 'cylinder') {
            geo = new THREE.CylinderGeometry(size[0]/2, size[0]/2, size[1], 32);
            shape = new CANNON.Cylinder(size[0]/2, size[0]/2, size[1], 16);
        }

        const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow = true; mesh.receiveShadow = true;
        this.scene.add(mesh);

        const body = new CANNON.Body({
            mass: mass,
            material: this.materials.standard,
            position: new CANNON.Vec3(x, y, z)
        });
        
        // Cannon cylinders align differently than Three
        if(type === 'cylinder') {
            let q = new CANNON.Quaternion();
            q.setFromAxisAngle(new CANNON.Vec3(1,0,0), Math.PI/2);
            body.addShape(shape, new CANNON.Vec3(0,0,0), q);
        } else {
            body.addShape(shape);
        }

        if(opts.rotation) body.quaternion.set(opts.rotation[0], opts.rotation[1], opts.rotation[2], opts.rotation[3]);

        this.world.addBody(body);
        
        const obj = { type: 'primitive', subType: type, mesh, body, opts: { size, color, mass } };
        this.objects.push(obj);
        return obj;
    },

    spawnCustomModel: function(name, x, y, z, rotation) {
        const def = this.customModels[name];
        if(!def) return null;

        const group = new THREE.Group();
        const body = new CANNON.Body({ mass: 10, material: this.materials.standard, position: new CANNON.Vec3(x, y, z) });

        def.parts.forEach(part => {
            let geo, shape;
            let sz = part.size.map(Number);
            let off = part.offset.map(Number);
            let c = part.color;

            if(part.type === 'box') {
                geo = new THREE.BoxGeometry(sz[0], sz[1], sz[2]);
                shape = new CANNON.Box(new CANNON.Vec3(sz[0]/2, sz[1]/2, sz[2]/2));
            } else if (part.type === 'sphere') {
                geo = new THREE.SphereGeometry(sz[0]/2, 16, 16);
                shape = new CANNON.Sphere(sz[0]/2);
            }
            
            const mat = new THREE.MeshStandardMaterial({ color: c });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(off[0], off[1], off[2]);
            mesh.castShadow = true; mesh.receiveShadow = true;
            group.add(mesh);

            body.addShape(shape, new CANNON.Vec3(off[0], off[1], off[2]));
        });

        if(rotation) body.quaternion.set(rotation[0], rotation[1], rotation[2], rotation[3]);

        this.scene.add(group);
        this.world.addBody(body);
        const obj = { type: 'custom', modelName: name, mesh: group, body: body };
        this.objects.push(obj);
        return obj;
    },

    syncPhysics: function() {
        for (let i = 0; i < this.objects.length; i++) {
            const obj = this.objects[i];
            if(obj.mesh && obj.body) {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            }
        }
    },

    animate: function() {
        if(!this.isRunning) return;
        requestAnimationFrame(() => this.animate());

        const delta = Math.min(this.clock.getDelta(), 0.1);

        // Logic Updates
        this.Player.update(delta);
        this.Tools.update(delta);
        this.Mod.update(delta);
        
        // Physics Step
        this.world.step(1/60, delta, 3);
        this.syncPhysics();
        this.Portals.updatePhysics();

        // Render pass
        this.Portals.renderViews();
        this.renderer.render(this.scene, this.camera);
    },

    lockPointer: function() {
        if(this.UI.isOpen) return;
        document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
        document.body.requestPointerLock();
    }
};

// ========================================================
// PLAYER CONTROLLER
// ========================================================
WG.Player = {
    yaw: new THREE.Object3D(),
    pitch: new THREE.Object3D(),
    body: null,
    canJump: false,
    speed: 30,

    init: function() {
        // Setup Hierarchy
        this.pitch.add(WG.camera);
        this.yaw.position.y = 1;
        this.yaw.add(this.pitch);
        WG.scene.add(this.yaw);

        // Physics Body
        const shape = new CANNON.Sphere(1);
        this.body = new CANNON.Body({ 
            mass: 50, 
            material: WG.materials.player, // 0 friction
            fixedRotation: true,
            linearDamping: 0.9 // Prevent infinite sliding
        });
        this.body.addShape(shape);
        this.body.position.set(0, 10, 10);
        WG.world.addBody(this.body);

        // Jump logic
        this.body.addEventListener("collide", (e) => {
            if(e.contact.ni.y > 0.5) this.canJump = true;
        });

        // Mouse look
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement !== document.body) return;
            this.yaw.rotation.y -= e.movementX * 0.002;
            this.pitch.rotation.x -= e.movementY * 0.002;
            this.pitch.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.pitch.rotation.x));
        });

        // Keys
        document.addEventListener('keydown', (e) => this.handleKey(e, true));
        document.addEventListener('keyup', (e) => this.handleKey(e, false));

        // Pointerlock monitoring
        document.addEventListener('pointerlockchange', () => {
            if(document.pointerLockElement !== document.body && WG.mode === 'sandbox') {
                if(!WG.UI.modalsOpen()) WG.UI.toggleQMenu(true);
            }
        });
    },

    handleKey: function(e, isDown) {
        const key = e.code.toLowerCase().replace('key', '');
        if(WG.keys.hasOwnProperty(key)) WG.keys[key] = isDown;

        // One-shot actions
        if(isDown && document.pointerLockElement === document.body) {
            if(e.code === 'Space' && this.canJump) {
                this.body.velocity.y = 12;
                this.canJump = false;
            }
            if(e.code === 'Digit1') WG.Tools.equip('physgun');
            if(e.code === 'Digit2') WG.Tools.equip('portal');
        }

        // Q-Menu release to close
        if(e.code === 'KeyQ' && !isDown && WG.mode === 'sandbox' && WG.UI.isOpen) {
             WG.UI.toggleQMenu(false);
             WG.lockPointer();
        }
    },

    update: function(delta) {
        // Sync position (camera at top of sphere)
        this.yaw.position.copy(this.body.position);
        this.yaw.position.y += 0.5;

        if (document.pointerLockElement !== document.body) return;

        // Movement Vectors
        const dir = new THREE.Vector3();
        if(WG.keys.w) dir.z -= 1;
        if(WG.keys.s) dir.z += 1;
        if(WG.keys.a) dir.x -= 1;
        if(WG.keys.d) dir.x += 1;

        if(dir.lengthSq() > 0) {
            dir.normalize();
            dir.applyEuler(new THREE.Euler(0, this.yaw.rotation.y, 0));
            
            // Apply snappy velocity
            this.body.velocity.x = dir.x * this.speed;
            this.body.velocity.z = dir.z * this.speed;
        } else {
            // High friction stopping
            this.body.velocity.x *= 0.8;
            this.body.velocity.z *= 0.8;
        }
    },

    getLookDir: function() {
        const v = new THREE.Vector3(0,0,-1);
        v.applyQuaternion(WG.camera.quaternion);
        v.applyQuaternion(this.yaw.quaternion);
        return v;
    }
};

// ========================================================
// TOOLS (Physgun & Portal)
// ========================================================
WG.Tools = {
    active: 'physgun',
    raycaster: new THREE.Raycaster(),

    // Physgun State
    heldBody: null, heldDist: 5, heldOffset: new CANNON.Vec3(), marker: null,

    init: function() {
        // Physgun Marker
        const geo = new THREE.SphereGeometry(0.15, 8, 8);
        const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
        this.marker = new THREE.Mesh(geo, mat);
        WG.scene.add(this.marker);
        this.marker.visible = false;

        document.addEventListener('mousedown', (e) => {
            if(document.pointerLockElement !== document.body) return;
            if(this.active === 'physgun') this.pgDown(e);
            if(this.active === 'portal') WG.Portals.shoot(e);
        });
        document.addEventListener('mouseup', (e) => {
            if(this.active === 'physgun' && e.button === 0) this.pgUp();
        });
        document.addEventListener('wheel', (e) => {
            if(document.pointerLockElement !== document.body) return;
            if(this.active === 'physgun' && this.heldBody) {
                this.heldDist -= Math.sign(e.deltaY) * 1.5;
                this.heldDist = Math.max(2, Math.min(this.heldDist, 100));
            }
        });
        document.addEventListener('keydown', (e) => {
            if(document.pointerLockElement !== document.body) return;
            if(e.code === 'KeyE' && this.active === 'physgun') this.pgUnfreeze();
        });
    },

    equip: function(tool) {
        if(WG.mode === 'main') return;
        this.active = tool;
        if(this.heldBody) this.pgUp(); // Drop
        
        const hTool = document.getElementById('hud-tool');
        const hDesc = document.getElementById('hud-desc');
        if(tool === 'physgun') {
            hTool.innerText = "PHYSGUN"; hTool.className = "text-4xl font-extrabold italic text-blue-400 tracking-wider";
            hDesc.innerText = "LMB: Grab | Scroll: Distance | RMB: Freeze | E: Unfreeze";
        } else {
            hTool.innerText = "PORTALGUN"; hTool.className = "text-4xl font-extrabold italic text-orange-500 tracking-wider";
            hDesc.innerText = "LMB: Blue Portal | RMB: Orange Portal";
        }
    },

    raycastObjects: function() {
        this.raycaster.setFromCamera({x:0, y:0}, WG.camera);
        // Intersect only physical objects, not players or markers
        const interactables = WG.objects.map(o => o.mesh).filter(m => m !== undefined);
        return this.raycaster.intersectObjects(interactables, true);
    },

    pgDown: function(e) {
        const hits = this.raycastObjects();
        if(hits.length === 0) return;

        const hit = hits[0];
        const obj = WG.objects.find(o => o.mesh === hit.object || (o.mesh.type === 'Group' && o.mesh.children.includes(hit.object)));
        
        if(!obj) return;

        if(e.button === 0) { // Grab
            if(obj.type === 'static' && obj.body.mass === 0) return; // Cant grab ground
            
            this.heldBody = obj.body;
            this.heldDist = hit.distance;
            this.marker.visible = true;
            document.getElementById('crosshair').classList.add('active');

            // Wake and make dynamic if frozen
            if(this.heldBody.type === CANNON.Body.STATIC) {
                this.heldBody.type = CANNON.Body.DYNAMIC;
                this.heldBody.mass = obj.opts ? obj.opts.mass : 5;
                this.heldBody.updateMassProperties();
            }
            
            // Calculate local offset from center of mass
            const hitPoint = new CANNON.Vec3(hit.point.x, hit.point.y, hit.point.z);
            this.heldBody.pointToLocalFrame(hitPoint, this.heldOffset);

        } else if (e.button === 2) { // Freeze
            if(this.heldBody) {
                this.freezeBody(this.heldBody);
                this.pgUp();
            } else if (obj.type !== 'static') {
                this.freezeBody(obj.body);
            }
        }
    },

    pgUp: function() {
        this.heldBody = null;
        this.marker.visible = false;
        document.getElementById('crosshair').classList.remove('active');
    },

    pgUnfreeze: function() {
        const hits = this.raycastObjects();
        if(hits.length > 0) {
            const obj = WG.objects.find(o => o.mesh === hits[0].object || (o.mesh.type === 'Group' && o.mesh.children.includes(hits[0].object)));
            if(obj && obj.body.type === CANNON.Body.STATIC && obj.type !== 'static') {
                obj.body.type = CANNON.Body.DYNAMIC;
                obj.body.mass = obj.opts ? obj.opts.mass : 5;
                obj.body.updateMassProperties();
                obj.body.wakeUp();
            }
        }
    },

    freezeBody: function(body) {
        body.velocity.set(0,0,0);
        body.angularVelocity.set(0,0,0);
        body.type = CANNON.Body.STATIC;
        body.mass = 0;
        body.updateMassProperties();
    },

    update: function() {
        if(this.heldBody) {
            // Target Position based on look direction and distance
            const camPos = WG.camera.getWorldPosition(new THREE.Vector3());
            const lookDir = WG.Player.getLookDir();
            const targetPos = camPos.add(lookDir.multiplyScalar(this.heldDist));
            
            this.marker.position.copy(targetPos);

            // Calculate current world position of the grabbed point
            const worldGripPoint = new CANNON.Vec3();
            this.heldBody.pointToWorldFrame(this.heldOffset, worldGripPoint);

            // Velocity-based manipulation (highly stable)
            const forceVec = new CANNON.Vec3(
                targetPos.x - worldGripPoint.x,
                targetPos.y - worldGripPoint.y,
                targetPos.z - worldGripPoint.z
            );
            
            // Apply proportional velocity to reach target
            this.heldBody.velocity.set(forceVec.x * 10, forceVec.y * 10, forceVec.z * 10);
            
            // Counteract gravity
            const antigrav = WG.world.gravity.scale(-1);
            this.heldBody.force.vadd(antigrav.scale(this.heldBody.mass), this.heldBody.force);

            // Strong angular damping to prevent spinning out of control
            this.heldBody.angularVelocity.scale(0.8, this.heldBody.angularVelocity);
        }
    }
};

// ========================================================
// PORTALS SYSTEM
// ========================================================
WG.Portals = {
    blue: null, orange: null,
    width: 3.5, height: 5.5,

    init: function() {
        this.rtBlue = new THREE.WebGLRenderTarget(512, 512);
        this.rtOrange = new THREE.WebGLRenderTarget(512, 512);
        this.camBlue = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        this.camOrange = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);

        const geo = new THREE.PlaneGeometry(this.width, this.height);
        
        // Blue Portal Mesh
        const mB = new THREE.MeshBasicMaterial({ map: this.rtBlue.texture, side: THREE.DoubleSide });
        this.meshBlue = new THREE.Mesh(geo, mB);
        const fb = new THREE.Mesh(new THREE.PlaneGeometry(this.width+0.4, this.height+0.4), new THREE.MeshBasicMaterial({color:0x0088ff}));
        fb.position.z = -0.01; this.meshBlue.add(fb);
        this.meshBlue.visible = false;
        WG.scene.add(this.meshBlue);

        // Orange Portal Mesh
        const mO = new THREE.MeshBasicMaterial({ map: this.rtOrange.texture, side: THREE.DoubleSide });
        this.meshOrange = new THREE.Mesh(geo, mO);
        const fo = new THREE.Mesh(new THREE.PlaneGeometry(this.width+0.4, this.height+0.4), new THREE.MeshBasicMaterial({color:0xff8800}));
        fo.position.z = -0.01; this.meshOrange.add(fo);
        this.meshOrange.visible = false;
        WG.scene.add(this.meshOrange);
    },

    clear: function() {
        this.meshBlue.visible = false; this.meshOrange.visible = false;
        this.blue = null; this.orange = null;
    },

    shoot: function(e) {
        if(e.button !== 0 && e.button !== 2) return;
        const hits = WG.Tools.raycastObjects();
        if(hits.length === 0) return;
        
        const hit = hits[0];
        const isBlue = e.button === 0;
        
        // Only place on static objects
        const obj = WG.objects.find(o => o.mesh === hit.object);
        if(!obj || obj.body.type !== CANNON.Body.STATIC) return;

        const mesh = isBlue ? this.meshBlue : this.meshOrange;
        
        // Position slightly off the surface to avoid z-fighting
        mesh.position.copy(hit.point).add(hit.face.normal.clone().multiplyScalar(0.02));
        
        // Align rotation to normal
        const lookPt = mesh.position.clone().add(hit.face.normal);
        mesh.lookAt(lookPt);
        mesh.visible = true;

        const pData = {
            pos: mesh.position.clone(),
            quat: mesh.quaternion.clone(),
            normal: hit.face.normal.clone()
        };

        if(isBlue) this.blue = pData;
        else this.orange = pData;
    },

    renderViews: function() {
        if(!this.blue || !this.orange) return;

        const mainCamPos = WG.camera.getWorldPosition(new THREE.Vector3());
        const mainCamQuat = WG.camera.getWorldQuaternion(new THREE.Quaternion());

        // Helper to setup virtual camera
        const setupCam = (cam, src, dest) => {
            // Transform matrix from Src -> Dest (with 180 Y flip)
            const qSrcInv = src.quat.clone().invert();
            const qY180 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI);
            const qTotal = new THREE.Quaternion().multiplyQuaternions(qY180, dest.quat).multiply(qSrcInv);

            // Offset
            const offset = mainCamPos.clone().sub(src.pos);
            offset.applyQuaternion(qTotal);
            cam.position.copy(dest.pos).add(offset);

            // Rotation
            cam.quaternion.copy(mainCamQuat).premultiply(qTotal);
            
            // Adjust near clipping plane to portal surface (simplified)
            cam.near = 0.5;
            cam.updateProjectionMatrix();
        };

        // Render Blue (seen from Orange)
        setupCam(this.camBlue, this.blue, this.orange);
        this.meshOrange.visible = false; // Hide destination to prevent infinite hall of mirrors
        WG.renderer.setRenderTarget(this.rtBlue);
        WG.renderer.clear();
        WG.renderer.render(WG.scene, this.camBlue);
        this.meshOrange.visible = true;

        // Render Orange (seen from Blue)
        setupCam(this.camOrange, this.orange, this.blue);
        this.meshBlue.visible = false;
        WG.renderer.setRenderTarget(this.rtOrange);
        WG.renderer.clear();
        WG.renderer.render(WG.scene, this.camOrange);
        this.meshBlue.visible = true;

        WG.renderer.setRenderTarget(null); // Return to main screen
    },

    updatePhysics: function() {
        if(!this.blue || !this.orange) return;

        // Check objects
        WG.objects.forEach(obj => {
            if(obj.body.type === CANNON.Body.STATIC) return;
            this.checkCrossing(obj.body, this.blue, this.orange);
            this.checkCrossing(obj.body, this.orange, this.blue);
        });

        // Check player
        this.checkCrossing(WG.Player.body, this.blue, this.orange, true);
        this.checkCrossing(WG.Player.body, this.orange, this.blue, true);
    },

    checkCrossing: function(body, src, dest, isPlayer=false) {
        // Simple distance and dot product check
        if(body.position.distanceTo(src.pos) < this.width / 1.5) {
            const vel = new THREE.Vector3(body.velocity.x, body.velocity.y, body.velocity.z);
            if(vel.lengthSq() < 0.1 && !isPlayer) return;

            vel.normalize();
            // If moving INTO the portal
            if(vel.dot(src.normal) < 0) {
                
                // Math transforms
                const qSrcInv = src.quat.clone().invert();
                const qY180 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI);
                const qTotal = new THREE.Quaternion().multiplyQuaternions(qY180, dest.quat).multiply(qSrcInv);

                // Transform Pos
                let posOffset = new THREE.Vector3().copy(body.position).sub(src.pos);
                posOffset.applyQuaternion(qTotal);
                body.position.copy(dest.pos).vadd(posOffset, body.position);
                
                // Push slightly forward to avoid getting stuck in destination plane
                const push = new CANNON.Vec3(dest.normal.x, dest.normal.y, dest.normal.z).scale(1.5);
                body.position.vadd(push, body.position);

                // Transform Velocity
                let v = new THREE.Vector3(body.velocity.x, body.velocity.y, body.velocity.z);
                v.applyQuaternion(qTotal);
                body.velocity.set(v.x, v.y, v.z);

                if(!isPlayer) {
                    // Transform Rotation
                    let q = new THREE.Quaternion(body.quaternion.x, body.quaternion.y, body.quaternion.z, body.quaternion.w);
                    q.premultiply(qTotal);
                    body.quaternion.set(q.x, q.y, q.z, q.w);
                } else {
                    // Rotate Player Camera Yaw
                    let playerQ = WG.Player.yaw.quaternion.clone();
                    playerQ.premultiply(qTotal);
                    
                    // Convert back to euler Y for the FPS controller
                    const euler = new THREE.Euler().setFromQuaternion(playerQ, 'YXZ');
                    WG.Player.yaw.rotation.y = euler.y;
                }
            }
        }
    }
};

// ========================================================
// USER INTERFACE
// ========================================================
WG.UI = {
    isOpen: false,
    
    init: function() {
        document.addEventListener('contextmenu', e => e.preventDefault());
    },

    toggleQMenu: function(show) {
        this.isOpen = show;
        const menu = document.getElementById('q-menu');
        if(show) {
            document.exitPointerLock();
            menu.classList.remove('hidden');
            this.switchTab('primitives');
        } else {
            menu.classList.add('hidden');
        }
    },

    switchTab: function(tab) {
        const c = document.getElementById('q-content');
        if(tab === 'primitives') {
            c.innerHTML = `
                <h3 class="text-white text-xl font-bold mb-4">Primitives</h3>
                <div class="grid grid-cols-4 gap-4">
                    <button class="bg-gray-700 hover:bg-gray-600 p-4 rounded-xl border border-gray-600 flex flex-col items-center shadow-lg transition" onclick="WG.UI.spawn('box')">
                        <div class="w-12 h-12 bg-blue-500 mb-2 border-2 border-black rounded-sm"></div>
                        <span class="text-white font-bold">Cube</span>
                    </button>
                    <button class="bg-gray-700 hover:bg-gray-600 p-4 rounded-xl border border-gray-600 flex flex-col items-center shadow-lg transition" onclick="WG.UI.spawn('sphere')">
                        <div class="w-12 h-12 bg-red-500 mb-2 border-2 border-black rounded-full"></div>
                        <span class="text-white font-bold">Sphere</span>
                    </button>
                    <button class="bg-gray-700 hover:bg-gray-600 p-4 rounded-xl border border-gray-600 flex flex-col items-center shadow-lg transition" onclick="WG.UI.spawn('cylinder')">
                        <div class="w-10 h-12 bg-green-500 mb-2 border-2 border-black rounded-md"></div>
                        <span class="text-white font-bold">Cylinder</span>
                    </button>
                </div>
            `;
        } else if (tab === 'custom') {
            let html = `<h3 class="text-white text-xl font-bold mb-4">Custom Library</h3><div class="grid grid-cols-4 gap-4">`;
            const keys = Object.keys(WG.customModels);
            if(keys.length === 0) {
                html += `<div class="col-span-4 text-gray-400 text-center mt-10">No custom models. Create one in the Model Maker!</div>`;
            } else {
                keys.forEach(k => {
                    html += `
                    <button class="bg-gray-700 hover:bg-gray-600 p-4 rounded-xl border border-purple-500 flex flex-col items-center shadow-lg transition" onclick="WG.UI.spawnCustom('${k}')">
                        <span class="text-4xl mb-2">üì¶</span>
                        <span class="text-white font-bold truncate w-full text-center text-sm">${k}</span>
                    </button>`;
                });
            }
            c.innerHTML = html + '</div>';
        }
    },

    spawn: function(type) {
        const dir = WG.Player.getLookDir();
        const pos = WG.camera.getWorldPosition(new THREE.Vector3()).add(dir.multiplyScalar(6));
        WG.spawnPrimitive(type, pos.x, pos.y, pos.z);
        this.toggleQMenu(false);
        WG.lockPointer();
    },

    spawnCustom: function(name) {
        const dir = WG.Player.getLookDir();
        const pos = WG.camera.getWorldPosition(new THREE.Vector3()).add(dir.multiplyScalar(6));
        WG.spawnCustomModel(name, pos.x, pos.y, pos.z);
        this.toggleQMenu(false);
        WG.lockPointer();
    },

    modalsOpen: function() {
        return !document.getElementById('model-maker').classList.contains('hidden') || 
               !document.getElementById('mod-creator').classList.contains('hidden');
    },

    openModelMaker: function() { document.getElementById('model-maker').classList.remove('hidden'); },
    openModCreator: function() { document.getElementById('mod-creator').classList.remove('hidden'); },
    closeModals: function() {
        document.getElementById('model-maker').classList.add('hidden');
        document.getElementById('mod-creator').classList.add('hidden');
    },

    // Model Maker Logic
    MM: {
        parts: [],
        addPart: function() {
            this.parts.push({ type: 'box', size: [2,2,2], offset: [0,0,0], color: '#ffffff' });
            this.render();
        },
        render: function() {
            const c = document.getElementById('mm-parts');
            c.innerHTML = '';
            this.parts.forEach((p, i) => {
                c.innerHTML += `
                <div class="bg-gray-800 p-3 rounded-lg flex items-center space-x-4 border border-gray-600 shadow-sm">
                    <select class="bg-gray-900 text-white rounded p-1 border border-gray-600" onchange="WG.UI.MM.upd(${i}, 'type', this.value)">
                        <option value="box" ${p.type==='box'?'selected':''}>Box</option>
                        <option value="sphere" ${p.type==='sphere'?'selected':''}>Sphere</option>
                    </select>
                    <div class="flex items-center space-x-1">
                        <span class="text-gray-400 text-xs">Size</span>
                        <input type="text" value="${p.size.join(',')}" class="w-16 bg-gray-900 text-white p-1 rounded border border-gray-600 text-xs" onchange="WG.UI.MM.upd(${i}, 'size', this.value.split(','))">
                    </div>
                    <div class="flex items-center space-x-1">
                        <span class="text-gray-400 text-xs">Off</span>
                        <input type="text" value="${p.offset.join(',')}" class="w-16 bg-gray-900 text-white p-1 rounded border border-gray-600 text-xs" onchange="WG.UI.MM.upd(${i}, 'offset', this.value.split(','))">
                    </div>
                    <input type="color" value="${p.color}" onchange="WG.UI.MM.upd(${i}, 'color', this.value)" class="h-6 w-6 cursor-pointer">
                    <button class="text-red-400 hover:text-red-300 font-bold ml-auto bg-gray-700 px-2 py-1 rounded" onclick="WG.UI.MM.rem(${i})">X</button>
                </div>`;
            });
        },
        upd: function(i, k, v) { this.parts[i][k] = v; },
        rem: function(i) { this.parts.splice(i, 1); this.render(); },
        save: function() {
            const name = document.getElementById('mm-name').value.trim() || "Prop_" + Math.floor(Math.random()*1000);
            if(this.parts.length === 0) return alert("Need at least 1 part!");
            WG.customModels[name] = { name: name, parts: JSON.parse(JSON.stringify(this.parts)) };
            WG.Data.saveModel(name, WG.customModels[name]);
            alert("Model Saved!");
            WG.UI.closeModals();
            WG.UI.switchTab('custom');
        }
    }
};

// ========================================================
// MOD API
// ========================================================
WG.Mod = {
    hooks: { onTick: [] },
    
    API: {
        spawn: (t, x, y, z, opts) => WG.spawnPrimitive(t, x, y, z, opts),
        onTick: (fn) => WG.Mod.hooks.onTick.push(fn),
        setGravity: (y) => WG.world.gravity.y = y,
        log: (msg) => console.log("[ModAPI]", msg)
    },

    execute: function() {
        const code = document.getElementById('mod-code').value;
        try {
            const fn = new Function('API', code);
            fn(this.API);
            alert("Mod Executed Successfully!");
            WG.UI.closeModals();
        } catch(e) {
            alert("Script Error:\n" + e.message);
        }
    },
    
    clear: function() {
        this.hooks.onTick = [];
        WG.world.gravity.set(0, -15, 0); // Reset grav
    },

    update: function(delta) {
        this.hooks.onTick.forEach(fn => {
            try { fn(delta); } catch(e){}
        });
    }
};

// ========================================================
// DATA PERSISTENCE
// ========================================================
WG.Data = {
    db: null,
    
    initDB: function() {
        return new Promise((resolve) => {
            const req = indexedDB.open("WebGMOD", 1);
            req.onupgradeneeded = e => {
                let db = e.target.result;
                if(!db.objectStoreNames.contains('models')) db.createObjectStore('models');
            };
            req.onsuccess = e => { this.db = e.target.result; resolve(); };
            req.onerror = () => resolve(); // Ignore errors, run memory only
        });
    },

    saveModel: function(name, data) {
        if(!this.db) return;
        const tx = this.db.transaction('models', 'readwrite');
        tx.objectStore('models').put(data, name);
    },

    loadCustomModels: function() {
        return new Promise(resolve => {
            if(!this.db) return resolve();
            const tx = this.db.transaction('models', 'readonly');
            const req = tx.objectStore('models').getAllKeys();
            req.onsuccess = () => {
                const keys = req.result;
                let loaded = 0;
                if(keys.length === 0) resolve();
                keys.forEach(k => {
                    const getReq = tx.objectStore('models').get(k);
                    getReq.onsuccess = e => {
                        WG.customModels[k] = e.target.result;
                        loaded++;
                        if(loaded === keys.length) resolve();
                    };
                });
            };
        });
    },

    serialize: function() {
        const state = { objects: [] };
        WG.objects.forEach(obj => {
            if(obj.type === 'static' || !obj.body) return; // Ignore ground
            state.objects.push({
                type: obj.type, subType: obj.subType, modelName: obj.modelName,
                opts: obj.opts,
                pos: [obj.body.position.x, obj.body.position.y, obj.body.position.z],
                quat: [obj.body.quaternion.x, obj.body.quaternion.y, obj.body.quaternion.z, obj.body.quaternion.w]
            });
        });
        return state;
    },

    deserialize: function(state) {
        WG.clearWorld();
        // Re-add ground
        const groundGeo = new THREE.PlaneGeometry(500, 500);
        const groundMesh = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({color:0x3d5a40}));
        groundMesh.rotation.x = -Math.PI / 2;
        WG.scene.add(groundMesh);
        const gBody = new CANNON.Body({ mass: 0, material: WG.materials.standard, shape: new CANNON.Plane() });
        gBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
        WG.world.addBody(gBody);
        WG.objects.push({ type: 'static', mesh: groundMesh, body: gBody });

        state.objects.forEach(data => {
            if(data.type === 'primitive') {
                WG.spawnPrimitive(data.subType, data.pos[0], data.pos[1], data.pos[2], Object.assign({}, data.opts, {rotation: data.quat}));
            } else if (data.type === 'custom') {
                WG.spawnCustomModel(data.modelName, data.pos[0], data.pos[1], data.pos[2], data.quat);
            }
        });
    },

    saveSlot: function() {
        const str = JSON.stringify(this.serialize());
        localStorage.setItem('webgmod_save', str);
        alert("World state saved to LocalStorage!");
    },

    exportFile: function() {
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.serialize()));
        const a = document.createElement('a');
        a.href = dataStr;
        a.download = "webgmod_world.json";
        a.click();
    },

    importFile: function() {
        const input = document.createElement('input');
        input.type = 'file'; input.accept = '.json';
        input.onchange = e => {
            const reader = new FileReader();
            reader.onload = ev => {
                try {
                    const state = JSON.parse(ev.target.result);
                    WG.launch('blank', 'sandbox');
                    setTimeout(() => WG.Data.deserialize(state), 500);
                } catch(err) { alert("Invalid save file."); }
            };
            reader.readAsText(e.target.files[0]);
        };
        input.click();
    }
};
</script>
</body>

</html>
