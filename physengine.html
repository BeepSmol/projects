<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Engine</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OBJ Loader for custom model importing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <!-- Cannon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Tahoma', 'Verdana', sans-serif; user-select: none; }
        #game-canvas { display: block; width: 100vw; height: 100vh; position: absolute; z-index: 1; }
        
        /* UI Layers */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 10; }
        .interactive { pointer-events: auto; }
        .hidden { display: none !important; }
        
        /* Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: white; border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; transition: all 0.1s ease; mix-blend-mode: difference;
        }
        #crosshair.active { width: 12px; height: 12px; background: transparent; border: 2px solid #00ff00; }
        
        /* Retro Windows 95 Style Utilities */
        .retro-panel { background-color: #c0c0c0; border-top: 2px solid #ffffff; border-left: 2px solid #ffffff; border-bottom: 2px solid #808080; border-right: 2px solid #808080; color: black; }
        .retro-inset { background-color: #ffffff; border-top: 2px solid #808080; border-left: 2px solid #808080; border-bottom: 2px solid #ffffff; border-right: 2px solid #ffffff; }
        .retro-button { background-color: #c0c0c0; border-top: 2px solid #ffffff; border-left: 2px solid #ffffff; border-bottom: 2px solid #404040; border-right: 2px solid #404040; color: black; font-weight: bold; cursor: pointer; }
        .retro-button:active { border-top: 2px solid #404040; border-left: 2px solid #404040; border-bottom: 2px solid #ffffff; border-right: 2px solid #ffffff; padding-top: 2px; padding-left: 2px; }
        .retro-title { background: linear-gradient(90deg, #000080, #1084d0); color: white; font-weight: bold; padding: 2px 4px; }

        /* Scrollbars */
        ::-webkit-scrollbar { width: 12px; }
        ::-webkit-scrollbar-track { background: #dfdfdf; border-left: 1px solid #808080; }
        ::-webkit-scrollbar-thumb { background: #c0c0c0; border: 1px solid #ffffff; border-bottom-color: #808080; border-right-color: #808080; }

        .code-editor { font-family: 'Courier New', monospace; tab-size: 4; white-space: pre; overflow-wrap: normal; overflow-x: auto; }
        #dynamic-ui { position: absolute; inset: 0; pointer-events: none; z-index: 20; }
        .dyn-element { pointer-events: auto; position: absolute; }
    </style>
</head>
<body>

    <!-- WebGL Canvas -->
    <canvas id="game-canvas"></canvas>

    <!-- UI Overlay -->
    <div id="ui-layer" class="ui-layer">
        
        <!-- Crosshair -->
        <div id="crosshair" class="hidden"></div>

        <!-- Dynamic Mod UI Container -->
        <div id="dynamic-ui"></div>

        <!-- Mod API: Currency / Score UI -->
        <div id="currency-ui" class="hidden absolute top-6 left-6 text-3xl font-bold text-yellow-400 drop-shadow-[0_2px_2px_rgba(0,0,0,1)] font-mono tracking-widest z-10">
            SCORE: <span id="currency-val">0</span>
        </div>

        <!-- Mod API: Game Over Screen -->
        <div id="game-over-ui" class="interactive hidden absolute inset-0 bg-red-900 bg-opacity-80 flex items-center justify-center z-50 flex-col backdrop-blur-sm">
            <h1 class="text-7xl font-black text-white mb-2 tracking-widest drop-shadow-lg">GAME OVER</h1>
            <p id="game-over-msg" class="text-2xl text-red-200 mb-8 font-bold"></p>
            <button class="retro-button px-8 py-3 text-xl" onclick="WG.Mod.resetGame()">Close & Restart</button>
            <button class="retro-button px-8 py-3 text-xl mt-4 bg-gray-300" onclick="WG.exitToMainMenu()">Main Menu</button>
        </div>

        <!-- HUD -->
        <div id="hud" class="hidden absolute bottom-6 right-8 text-right drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)]">
            <h1 class="text-4xl font-extrabold italic text-blue-400 tracking-wider" id="hud-tool">PHYSGUN</h1>
            <p class="text-sm text-gray-200 font-semibold" id="hud-desc">LMB: Grab | Scroll: Distance | RMB: Freeze | E: Unfreeze</p>
            <div class="mt-3 flex justify-end gap-2 text-xs font-bold text-gray-400">
                <span class="bg-gray-800 bg-opacity-70 px-2 py-1 border border-gray-600">1: Physgun</span>
                <span class="bg-gray-800 bg-opacity-70 px-2 py-1 border border-gray-600">2: Portal Gun</span>
                <span class="bg-gray-800 bg-opacity-70 px-2 py-1 border border-gray-600">3: Anchor</span>
                <span class="bg-gray-800 bg-opacity-70 px-2 py-1 border border-gray-600 text-yellow-400">T: Thrusters</span>
                <span class="bg-gray-800 bg-opacity-70 px-2 py-1 border border-gray-600">Q/Esc: Menu</span>
                <span class="bg-gray-800 bg-opacity-70 px-2 py-1 border border-gray-600">~: Console</span>
            </div>
        </div>

        <!-- Command Console -->
        <div id="console" class="interactive hidden absolute top-0 left-0 w-full bg-black bg-opacity-90 border-b-2 border-green-600 z-[90] flex flex-col p-2 font-mono text-sm shadow-2xl">
            <div class="flex justify-between text-gray-400 mb-1 border-b border-gray-700 pb-1">
                <span>Developer Console (Press ~ to close)</span>
                <button onclick="WG.UI.toggleConsole()" class="hover:text-white">X</button>
            </div>
            <div id="console-output" class="h-48 overflow-y-auto text-green-400 mb-2 p-1"></div>
            <div class="flex">
                <span class="text-green-500 mr-2">></span>
                <input type="text" id="console-input" class="flex-1 bg-transparent text-white outline-none" autocomplete="off" spellcheck="false" placeholder="Enter Javascript API command...">
            </div>
        </div>

        <script>window.WG = window.WG || {};</script>
        <!-- Retro Launch Screen -->
        <div id="launch-screen" class="interactive absolute inset-0 bg-teal-800 flex items-center justify-center z-[100]">
            <div class="retro-panel w-full max-w-3xl flex flex-col shadow-2xl">
                <div class="retro-title flex justify-between">
                    <span>PhysicsEngine_Launch.exe</span>
                </div>
                
                <div class="p-6 flex flex-col md:flex-row gap-6">
                    <!-- Retro Info -->
                    <div class="flex-1 retro-inset p-4 text-sm flex flex-col justify-between">
                        <div>
                            <h2 class="text-lg font-bold mb-2 border-b border-gray-400 pb-1">Instructions</h2>
                            <ul class="space-y-2 text-gray-800">
                                <li><b>W A S D</b> - Traverse environment</li>
                                <li><b>Space</b> - Execute Jump</li>
                                <li><b>Q / Esc</b> - Toggle Main Interface</li>
                                    <li><b>U</b> - Unlock / Lock Mouse</li>
                                <li><b>1 / 2 / 3</b> - Select Active Device</li>
                                <li><b>Z / X / C</b> - Rotate Object</li>
                                <li><b>PLEASE</b> Ignore portals when they bug out.</li>
                            </ul>
                        </div>
                        <div class="mt-4 pt-2 border-t border-gray-400 text-xs text-gray-600">
                            Version 4.0<br>
                            Includes: Console, Advanced Collisions, Constraints, Thrusters, Minigame Exports!
                        </div>
                    </div>

                    <!-- Launch Options -->
                    <div class="flex-1 flex flex-col justify-center space-y-4">
                        <div class="text-center mb-2">
                            <h1 class="text-4xl font-black text-gray-800 tracking-tighter">Physics Engine</h1>
                        </div>
                        
                        <button id="launch-blank" class="retro-button w-full py-4 text-lg">
                            Load Blank Canvas
                        </button>
                        <button id="launch-demo" class="retro-button w-full py-4 text-lg">
                            Load Demo World
                        </button>
                        <button class="retro-button w-full py-2 text-sm mt-4" onclick="WG.Data.importFile()">
                            Import Save File (.json)
                        </button>
                        <button class="retro-button w-full py-2 text-sm mt-2 bg-red-200 text-red-900" onclick="WG.Data.clearAll()">
                            Clear Saved Data
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- File Import Mode Screen -->
        <div id="import-mode-screen" class="interactive hidden absolute inset-0 bg-teal-800 flex items-center justify-center z-[105]">
            <div class="retro-panel p-6 shadow-2xl text-center max-w-md w-full">
                <div class="retro-title mb-4 text-left">System Alert - World Loaded</div>
                <h2 class="text-xl font-bold mb-2">Select Execution Mode</h2>
                <p class="text-sm mb-6">Do you want to play this world as a game, or edit it?</p>
                <div class="flex gap-4">
                    <button class="retro-button px-4 py-3 w-full font-bold text-blue-900" onclick="WG.Data.resumeImport('play')">Play Game Mode</button>
                    <button class="retro-button px-4 py-3 w-full font-bold text-green-900" onclick="WG.Data.resumeImport('sandbox')">Sandbox (Edit)</button>
                </div>
            </div>
        </div>

        <!-- Q-Menu -->
        <div id="q-menu" class="interactive hidden absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-40 backdrop-blur-sm">
            <div class="retro-panel w-[85%] h-[85%] flex flex-col shadow-2xl">
                <div class="retro-title flex justify-between">
                    <span>Sandbox Menu & Tools</span>
                    <button class="bg-gray-300 text-black px-1 border border-gray-100 border-b-gray-600 border-r-gray-600 text-xs cursor-pointer font-bold leading-none flex items-center" onclick="WG.UI.toggleQMenu(false); WG.lockPointer();">X</button>
                </div>
                <div class="flex flex-1 overflow-hidden">
                    <!-- Sidebar -->
                    <div class="w-64 p-3 flex flex-col border-r border-gray-500 bg-[#d4d0c8]">
                        <div class="flex-1 space-y-2">
                            <button class="retro-button w-full text-left px-3 py-2" onclick="WG.UI.switchTab('primitives')">Primitives & Props</button>
                            <button class="retro-button w-full text-left px-3 py-2" onclick="WG.UI.switchTab('custom')">Custom Models</button>
                            <button class="retro-button w-full text-left px-3 py-2" onclick="WG.UI.switchTab('settings')">World Settings</button>
                        </div>
                        <div class="space-y-2 pt-4 border-t border-gray-500">
                            <button class="retro-button w-full py-2 bg-purple-200" onclick="WG.UI.openModelMaker()">Model Maker</button>
                            <button class="retro-button w-full py-2 bg-blue-200" onclick="WG.UI.openModCreator()">Mod API Editor</button>
                            <button class="retro-button w-full py-2 bg-green-200" onclick="WG.UI.openMaterialEditor()">Material Editor</button>
                        </div>
                        <div class="space-y-2 pt-4 border-t border-gray-500 mt-4">
                            <button class="retro-button w-full py-1 text-sm" onclick="WG.Data.exportFile()">Export World & Scripts</button>
                        </div>
                        <div class="pt-4 mt-4 space-y-2">
                            <button class="retro-button w-full py-2 bg-red-200 text-red-900" onclick="WG.UI.toggleQMenu(false); WG.lockPointer();">Resume (Esc)</button>
                            <button class="retro-button w-full py-2 bg-gray-400 text-black" onclick="WG.exitToMainMenu()">Main Menu</button>
                        </div>
                    </div>
                    <!-- Content Area -->
                    <div class="flex-1 p-6 overflow-y-auto retro-inset m-2 bg-gray-100" id="q-content">
                        <!-- Injected via JS -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Visual Model Maker Modal -->
        <div id="model-maker" class="interactive hidden absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50">
            <div class="retro-panel w-[900px] h-[600px] flex flex-col shadow-2xl">
                <div class="retro-title flex justify-between">
                    <span>Visual Model Maker.exe</span>
                    <button class="bg-gray-300 text-black px-1 border border-gray-100 border-b-gray-600 border-r-gray-600 text-xs cursor-pointer font-bold leading-none flex items-center" onclick="WG.UI.closeModals()">&times;</button>
                </div>
                <div class="flex-1 flex overflow-hidden">
                    <div class="w-1/2 bg-black border-r border-gray-500 relative retro-inset m-2">
                        <canvas id="mm-canvas" class="w-full h-full absolute inset-0"></canvas>
                        <div class="absolute top-2 left-2 text-xs text-white bg-black bg-opacity-50 px-2 py-1 border border-white">Live Preview</div>
                    </div>
                    <div class="w-1/2 p-3 flex flex-col">
                        <div class="flex flex-col space-y-2 mb-4 bg-[#d4d0c8] p-2 border border-gray-500">
                            <input type="text" id="mm-name" placeholder="Prop Name (e.g. Chair)" class="retro-inset px-2 py-1 flex-1 text-sm w-full">
                            <div class="flex justify-between items-center text-sm">
                                <label><input type="checkbox" id="mm-bouncy" class="mr-1"> Bouncy Material</label>
                                <label>Mass: <input type="number" id="mm-mass" value="5" class="retro-inset w-16 px-1 ml-1"></label>
                            </div>
                            <button class="retro-button py-1 mt-2 w-full" onclick="WG.UI.MM.addPart()">+ Add Part</button>
                        </div>
                        <div class="flex-1 overflow-y-auto retro-inset p-2 space-y-2 bg-gray-100" id="mm-parts"></div>
                    </div>
                </div>
                <div class="p-3 border-t border-gray-500 flex justify-end bg-[#d4d0c8]">
                    <button class="retro-button px-8 py-2 font-bold" onclick="WG.UI.MM.save()">Save to Library</button>
                </div>
            </div>
        </div>

        <!-- Material Editor Modal -->
        <div id="material-editor" class="interactive hidden absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50">
            <div class="retro-panel w-[500px] h-[220px] flex flex-col shadow-2xl">
                <div class="retro-title flex justify-between">
                    <span>Material Editor</span>
                    <button class="bg-gray-300 text-black px-1 border border-gray-100 border-b-gray-600 border-r-gray-600 text-xs cursor-pointer font-bold leading-none flex items-center" onclick="document.getElementById('material-editor').classList.add('hidden')">&times;</button>
                </div>
                <div class="p-4 flex flex-col gap-3">
                    <p class="text-sm">Click an object in the scene to select it, then choose a color.</p>
                    <div class="flex gap-2 items-center">
                        <input type="color" id="mat-color" value="#ffffff" class="h-10 w-12">
                        <button class="retro-button px-4 py-2" onclick="WG.UI.applyMaterialToSelection()">Apply Color</button>
                        <button class="retro-button px-4 py-2" onclick="WG.UI.selectMaterialFromPointer()">Select From Pointer</button>
                    </div>
                    <div class="text-xs text-gray-600">Selected object id: <span id="mat-selected">none</span></div>
                </div>
            </div>
        </div>

        <!-- Mod Creator Modal -->
        <div id="mod-creator" class="interactive hidden absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50">
            <div class="retro-panel w-[1000px] h-[700px] flex flex-col shadow-2xl">
                <div class="retro-title flex justify-between">
                    <span>Mod API Studio (Script Editor)</span>
                    <button class="bg-gray-300 text-black px-1 border border-gray-100 border-b-gray-600 border-r-gray-600 text-xs cursor-pointer font-bold leading-none flex items-center" onclick="WG.UI.closeModals()">&times;</button>
                </div>
                
                <div class="flex-1 flex overflow-hidden">
                    <div class="w-1/3 p-4 overflow-y-auto border-r border-gray-500 bg-[#d4d0c8]">
                        <h3 class="font-bold mb-2 underline">API Documentation</h3>
                        <div class="text-[11px] space-y-3 text-black leading-tight">
                            <div class="bg-white border border-gray-400 p-1">
                                <strong>API.spawn(type, x, y, z, options)</strong><br>
                                Opts: {size:[w,h,d], color:hex, mass:int, modTag:'name'}
                            </div>
                            <div class="bg-white border border-gray-400 p-1">
                                <strong>API.onTick( callback(delta) )</strong>
                            </div>
                            <div class="bg-white border border-gray-400 p-1">
                                <strong>API.onCollide( callback(objA, objB) )</strong><br>
                                Passes string tags (e.g. 'player', 'danger', 'coin')
                            </div>
                            <div class="bg-white border border-gray-400 p-1">
                                <strong>API.createButton(id, text, x, y, onClick)</strong><br>
                                <strong>API.createText(id, text, x, y, color)</strong><br>
                                <strong>API.clearUI()</strong>
                            </div>
                            <div class="bg-white border border-gray-400 p-1 text-blue-800">
                                <strong>API.setCurrency(val) / API.addCurrency(val)</strong><br>
                                <strong>API.gameOver(message)</strong><br>
                                <strong>API.print(message)</strong> - Writes to Console
                            </div>
                            <div class="bg-white border border-gray-400 p-1">
                                <strong>API.onKeyDown(fn) / API.onKeyUp(fn)</strong><br>
                                Register keyboard event callbacks for mods
                            </div>
                            <div class="bg-white border border-gray-400 p-1">
                                <strong>API.freezePermanent(objectId)</strong><br>
                                Permanently freeze an object in-place until unfrozen by API
                            </div>
                            <div class="bg-white border border-gray-400 p-1">
                                <strong>API.setGravity(value)</strong><br>
                                Adjust world gravity (negative values pull down)
                            </div>
                            
                            <hr class="border-gray-500 my-2">
                            <h3 class="font-bold mb-1">Load Templates</h3>
                            <button class="retro-button w-full py-1 text-xs mb-1" onclick="WG.Mod.loadExample('minigame')">"Dodge the Anvil" (Game)</button>
                            <button class="retro-button w-full py-1 text-xs mb-1" onclick="WG.Mod.loadExample('clicker')">"Coin Collector" (Game)</button>
                            <button class="retro-button w-full py-1 text-xs mb-1" onclick="WG.Mod.loadExample('ui')">"Custom UI & Gravity" (Tool)</button>
                        </div>
                    </div>
                    
                    <div class="w-2/3 flex flex-col p-2 bg-[#d4d0c8]">
                        <textarea id="mod-code" class="code-editor flex-1 retro-inset p-2 text-sm text-black focus:outline-none resize-none" spellcheck="false">
// Welcome to the Mod Builder!
API.print("Script Loaded!");
                        </textarea>
                    </div>
                </div>

                <div class="p-3 border-t border-gray-500 flex justify-end space-x-2 bg-[#d4d0c8]">
                    <button class="retro-button px-6 py-1 text-gray-800" onclick="WG.Mod.importScript()">Import Script (.js)</button>
                    <button class="retro-button px-6 py-1 text-gray-800" onclick="WG.Mod.exportScript()">Export Script (.js)</button>
                    <button class="retro-button px-6 py-1 text-red-800" onclick="WG.Mod.clear()">Clear Scripts</button>
                    <button class="retro-button px-6 py-1 font-bold text-blue-900" onclick="WG.Mod.execute()">Inject & Run Script</button>
                </div>
            </div>
        </div>

    </div>

<script>
/**
 * Physics Engine v4.0 (3D Three.js + Cannon.js)
 */
window.WG = {
    mode: 'sandbox',
    objects: [], customModels: {}, constraints: [],
    
    scene: null, camera: null, renderer: null, world: null, clock: null,
    materials: {},
    
    isRunning: false,
    keys: { w: false, a: false, s: false, d: false, space: false, t: false },
    thrustersActive: false,
    timeScale: 1,
    _suppressMenuOnUnlock: false,
    
    terminalVelocityDown: -50,
    gravity: -25,

    tryLaunch: function(template) {
        console.log("tryLaunch", template);
        try { WG.launch(template, 'sandbox'); } catch(e) { console.error('launch error', e); }
    },
    launch: async function(template, mode) {
        console.log("WG.launch called", template, mode);
        try {
            this.mode = mode || 'sandbox';
            try { if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(()=>{}); } catch(e) {}

            document.getElementById('launch-screen').classList.add('hidden');
            document.getElementById('crosshair').classList.remove('hidden');
            
            if(this.mode === 'sandbox') {
                document.getElementById('hud').classList.remove('hidden');
            } else {
                document.getElementById('hud').classList.add('hidden');
                // Hide tool visuals in play mode
                WG.Tools.equip('none');
            }

            await this.Data.initDB();
            
            if(!this.scene) { 
                this.initEngine();
                this.Player.init();
                this.Tools.init();
                this.Portals.init();
                this.UI.init();
                this.Mod.init();
            }

            await this.Data.loadCustomModels();

            if (template === 'premade') this.buildPremade();
            else if (template === 'blank') this.buildBlank();

            this.isRunning = true;
            this.animate();
            this.lockPointer();
        } catch(err) {
            console.error("Error during launch", err);
            alert("Failed to start: " + err.message);
            document.getElementById('launch-screen').classList.remove('hidden');
        }
    },


    exitToMainMenu: function() {
        this.isRunning = false;
        document.exitPointerLock();
        this.UI.hideAll();
        document.getElementById('launch-screen').classList.remove('hidden');
        this.Mod.clear();
        this.clearWorld();
    },

    initEngine: function() {
        const canvas = document.getElementById('game-canvas');
        
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x7ec0ee); 
        this.scene.fog = new THREE.FogExp2(0x7ec0ee, 0.002);

        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        this.renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambient);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(100, 200, 50);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 150; dirLight.shadow.camera.bottom = -150;
        dirLight.shadow.camera.left = -150; dirLight.shadow.camera.right = 150;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        this.scene.add(dirLight);

        this.world = new CANNON.World();
        this.world.gravity.set(0, this.gravity, 0);
        this.world.broadphase = new CANNON.NaiveBroadphase();
        this.world.solver.iterations = 40; 
        
        this.materials.standard = new CANNON.Material("standard");
        this.materials.player = new CANNON.Material("player");
        this.materials.bouncy = new CANNON.Material("bouncy");
        
        const playerMat = new CANNON.ContactMaterial(this.materials.standard, this.materials.player, { friction: 0.0, restitution: 0.0 });
        const stdMat = new CANNON.ContactMaterial(this.materials.standard, this.materials.standard, { friction: 0.6, restitution: 0.1 });
        const bouncyMat = new CANNON.ContactMaterial(this.materials.standard, this.materials.bouncy, { friction: 0.3, restitution: 0.9 });
        
        this.world.addContactMaterial(playerMat);
        this.world.addContactMaterial(stdMat);
        this.world.addContactMaterial(bouncyMat);

        this.clock = new THREE.Clock();

        // Initialize input subsystem for API key listeners
        if(!this.Input) this.Input = {};
        if(typeof this.Input.init === 'function') this.Input.init();
        if(WG.System && WG.System.Sound && typeof WG.System.Sound.init === 'function') WG.System.Sound.init();

        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.Portals.resize(); 
        });

        // Key tracking for thrusters
        window.addEventListener('keydown', (e) => {
            if(e.code === 'KeyT' && document.pointerLockElement === document.body) this.thrustersActive = true;
        });
        window.addEventListener('keyup', (e) => {
            if(e.code === 'KeyT') this.thrustersActive = false;
        });
    },

    clearWorld: function() {
        this.objects.forEach(obj => {
            if(obj.mesh) this.scene.remove(obj.mesh);
            if(obj.body) this.world.remove(obj.body);
        });
        this.objects = [];
        this.constraints.forEach(c => this.world.removeConstraint(c));
        this.constraints = [];
        this.Portals.clear();
    },

    buildBlank: function() {
        this.clearWorld();
        const groundGeo = new THREE.PlaneGeometry(1000, 1000);
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#4a5d4e'; ctx.fillRect(0,0,256,256);
        ctx.fillStyle = '#3c4d3f'; ctx.fillRect(0,0,128,128); ctx.fillRect(128,128,128,128);
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(150, 150);

        const groundMat = new THREE.MeshStandardMaterial({ map: tex, roughness: 1.0 });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        this.scene.add(groundMesh);

        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, material: this.materials.standard });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
        this.world.addBody(groundBody);

        this.objects.push({ id: 'ground', type: 'static', mesh: groundMesh, body: groundBody, opts: { isGround: true } });
        
        this.Player.body.position.set(0, 10, 10);
        this.Player.body.velocity.set(0,0,0);
    },

    buildPremade: function() {
        this.buildBlank();
        this.spawnPrimitive('box', 0, 25, -100, { size: [200, 50, 4], isStatic: true, color: '#aaaaaa' });
        this.spawnPrimitive('box', 0, 25, 100, { size: [200, 50, 4], isStatic: true, color: '#aaaaaa' });
        this.spawnPrimitive('box', -100, 25, 0, { size: [4, 50, 200], isStatic: true, color: '#aaaaaa' });
        this.spawnPrimitive('box', 100, 25, 0, { size: [4, 50, 200], isStatic: true, color: '#aaaaaa' });

        let ramp1 = this.spawnPrimitive('box', 0, 5, -30, { size: [20, 1, 40], isStatic: true, color: '#8b5a2b' });
        ramp1.body.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), 0.25);
        
        let ramp2 = this.spawnPrimitive('box', 40, 10, -50, { size: [30, 2, 80], isStatic: true, color: '#6b4226' });
        ramp2.body.quaternion.setFromAxisAngle(new CANNON.Vec3(0,0,1), -0.4);

        for(let i=0; i<6; i++) {
            this.spawnPrimitive('box', -20, i*4 + 2, -20, { size: [4,4,4], color: '#d32f2f', mass: 10 });
        }
        
        this.spawnPrimitive('sphere', 20, 20, -10, { size: [4], color: '#388e3c', mass: 5, bouncy: true });
        
        // Example Thruster and Balloon
        this.spawnPrimitive('cylinder', 10, 5, 10, { size: [2,4], color: '#ffaa00', mass: 2, isThruster: true });
        this.spawnPrimitive('sphere', -10, 5, 10, { size: [4], color: '#ff66b2', mass: 0.5, isBalloon: true });
    },

    // buildTerrain removed â€” terrain gamemode deprecated and removed

    spawnPrimitive: function(type, x, y, z, opts = {}) {
        let size = opts.size || [2, 2, 2];
        let color = opts.color || Math.floor(Math.random() * 0xffffff);
        let mass = opts.isStatic ? 0 : (opts.mass !== undefined ? opts.mass : 5);
        let matType = opts.bouncy ? this.materials.bouncy : this.materials.standard;

        let geo, shape;
        if(type === 'box') {
            geo = new THREE.BoxGeometry(size[0], size[1], size[2]);
            shape = new CANNON.Box(new CANNON.Vec3(size[0]/2, size[1]/2, size[2]/2));
        } else if (type === 'sphere') {
            geo = new THREE.SphereGeometry(size[0]/2, 32, 32);
            shape = new CANNON.Sphere(size[0]/2);
        } else if (type === 'cylinder') {
            geo = new THREE.CylinderGeometry(size[0]/2, size[0]/2, size[1], 32);
            shape = new CANNON.Cylinder(size[0]/2, size[0]/2, size[1], 16);
        }

        const mat = new THREE.MeshStandardMaterial({ color: color, roughness: opts.bouncy? 0.1 : 0.8 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow = true; mesh.receiveShadow = true;
        this.scene.add(mesh);

        const body = new CANNON.Body({
            mass: mass,
            material: matType,
            position: new CANNON.Vec3(x, y, z)
        });
        // Enable sleeping to reduce CPU for idle objects
        body.allowSleep = true;
        body.sleepSpeedLimit = 0.1;
        body.sleepTimeLimit = 1;
        
        if(type === 'cylinder') {
            let q = new CANNON.Quaternion();
            q.setFromAxisAngle(new CANNON.Vec3(1,0,0), Math.PI/2);
            body.addShape(shape, new CANNON.Vec3(0,0,0), q);
        } else {
            body.addShape(shape);
        }

        if(opts.rotation) body.quaternion.set(opts.rotation[0], opts.rotation[1], opts.rotation[2], opts.rotation[3]);

        // explicitly clear velocity so they don't fling
        body.velocity.set(0,0,0);
        body.angularVelocity.set(0,0,0);

        // Attach collide listener for Mod API
        body.addEventListener("collide", (e) => {
            if(WG.Mod.hooks.onCollide) {
                const bA = e.body; // other body
                const bB = e.target; // this body
                const objA = WG.objects.find(o=>o.body===bA);
                const objB = WG.objects.find(o=>o.body===bB);
                let tagA = objA ? (objA.opts.modTag || objA.subType || "prop") : (bA === WG.Player.body ? 'player' : 'world');
                let tagB = objB ? (objB.opts.modTag || objB.subType || "prop") : 'world';
                WG.Mod.hooks.onCollide(tagA, tagB);
            }
        });

        this.world.addBody(body);
        
        const obj = { id: Math.random().toString(36).substr(2,9), type: 'primitive', subType: type, mesh, body, opts: { size, color, mass, bouncy: opts.bouncy, isThruster: opts.isThruster, isBalloon: opts.isBalloon, modTag: opts.modTag } };
        
        this.objects.push(obj);
        return obj;
    },

    spawnCustomModel: function(name, x, y, z, rotation) {
        const def = this.customModels[name];
        if(!def) return null;

        const group = new THREE.Group();
        const matType = def.bouncy ? this.materials.bouncy : this.materials.standard;
        const totalMass = def.mass !== undefined ? parseFloat(def.mass) : 5;

        const body = new CANNON.Body({ mass: totalMass, material: matType, position: new CANNON.Vec3(x, y, z) });
        body.velocity.set(0,0,0);
        body.allowSleep = true;
        body.sleepSpeedLimit = 0.1;
        body.sleepTimeLimit = 1;

        def.parts.forEach(part => {
            let geo, shape;
            let sz = part.size.map(Number);
            let off = part.offset.map(Number);
            
            if(part.type === 'box') {
                geo = new THREE.BoxGeometry(sz[0], sz[1], sz[2]);
                shape = new CANNON.Box(new CANNON.Vec3(sz[0]/2, sz[1]/2, sz[2]/2));
            } else if (part.type === 'sphere') {
                geo = new THREE.SphereGeometry(sz[0]/2, 16, 16);
                shape = new CANNON.Sphere(sz[0]/2);
            }
            
            const mat = new THREE.MeshStandardMaterial({ color: part.color, roughness: def.bouncy ? 0.2 : 0.7 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(off[0], off[1], off[2]);
            mesh.castShadow = true; mesh.receiveShadow = true;
            group.add(mesh);

            body.addShape(shape, new CANNON.Vec3(off[0], off[1], off[2]));
        });

        if(rotation) body.quaternion.set(rotation[0], rotation[1], rotation[2], rotation[3]);

        this.scene.add(group);
        this.world.addBody(body);
        const obj = { id: Math.random().toString(36).substr(2,9), type: 'custom', modelName: name, mesh: group, body: body, opts: {mass: totalMass} };
        this.objects.push(obj);
        return obj;
    },

    syncPhysics: function() {
        for (let i = 0; i < this.objects.length; i++) {
            const obj = this.objects[i];
            if(obj.mesh && obj.body) {
                if (obj.body.velocity.y < this.terminalVelocityDown) obj.body.velocity.y = this.terminalVelocityDown;
                
                // Thrusters
                if(obj.opts.isThruster && this.thrustersActive && document.pointerLockElement) {
                    // Apply force locally "up" along the cylinder
                    const localForce = new CANNON.Vec3(0, obj.body.mass * 30, 0);
                    const worldForce = obj.body.quaternion.vmult(localForce);
                    obj.body.applyForce(worldForce, obj.body.position);
                }

                // Balloons
                if(obj.opts.isBalloon) {
                    const floatForce = new CANNON.Vec3(0, obj.body.mass * (-this.gravity + 5), 0);
                    obj.body.applyForce(floatForce, obj.body.position);
                }

                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            }
        }
        
        if(this.Player.body && this.Player.body.velocity.y < this.terminalVelocityDown) {
            this.Player.body.velocity.y = this.terminalVelocityDown;
        }
    },

    animate: function() {
        if(!this.isRunning) return;
        requestAnimationFrame(() => this.animate());

        if(this.Mod.isGameOver) return; 

        const rawDelta = Math.min(this.clock.getDelta(), 0.1);
        const delta = rawDelta * (this.timeScale || 1);

        this.Player.update(delta);
        this.Tools.update(delta);
        this.Mod.update(delta);

        this.world.step(1/60, delta, 3);
        this.syncPhysics();
        this.Portals.updatePhysics();

        this.Portals.renderViews();
        this.renderer.render(this.scene, this.camera);

        if(this.UI.MM.isOpen) this.UI.MM.renderPreview();
    },

    lockPointer: function() {
        if(this.UI.isOpen || this.UI.modalsOpen() || this.Mod.isGameOver || !this.isRunning) return;
        document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
        document.body.requestPointerLock();
    }
};

// Input subsystem: key listeners and API hook support
WG.Input = {
    keys: {},
    keyDownListeners: [],
    keyUpListeners: [],
    init: function() {
        window.addEventListener('keydown', (e) => {
            const code = e.code || '';
            this.keys[code] = true;
            // Global convenience bindings
            if(code === 'KeyU') {
                try {
                    if(document.pointerLockElement === document.body) {
                        WG._suppressMenuOnUnlock = true;
                        document.exitPointerLock();
                    } else {
                        WG._suppressMenuOnUnlock = false;
                        document.body.requestPointerLock();
                    }
                } catch(e){}
            }
            if(code === 'KeyR') { // Throw if holding
                if(WG.Tools && WG.Tools.heldBody) {
                    const camDir = new THREE.Vector3(); WG.camera.getWorldDirection(camDir);
                    const impulse = new CANNON.Vec3(camDir.x * 30 * (WG.Tools.heldBody.mass||1), camDir.y * 30 * (WG.Tools.heldBody.mass||1), camDir.z * 30 * (WG.Tools.heldBody.mass||1));
                    WG.Tools.heldBody.velocity.vadd(impulse, WG.Tools.heldBody.velocity);
                    WG.Tools.pgUp();
                }
            }

            // Rotation shortcuts while holding: Z/X/C
            if((code === 'KeyZ' || code === 'KeyX' || code === 'KeyC') && WG.Tools && WG.Tools.heldBody) {
                const axisMap = { 'KeyZ': new CANNON.Vec3(0,0,1), 'KeyX': new CANNON.Vec3(1,0,0), 'KeyC': new CANNON.Vec3(0,1,0) };
                const axis = axisMap[code];
                const q = new CANNON.Quaternion();
                q.setFromAxisAngle(axis, Math.PI/2);
                WG.Tools.heldBody.quaternion = WG.Tools.heldBody.quaternion.mult(q);
                // update visual
                const obj = WG.objects.find(o => o.body === WG.Tools.heldBody);
                if(obj && obj.mesh) obj.mesh.quaternion.copy(WG.Tools.heldBody.quaternion);
            }

            // dispatch to registered listeners
            this.keyDownListeners.forEach(fn => { try{ fn(e); }catch(e){} });
        });

        window.addEventListener('keyup', (e) => {
            const code = e.code || '';
            this.keys[code] = false;
            this.keyUpListeners.forEach(fn => { try{ fn(e); }catch(e){} });
        });
    },
    onKeyDown: function(fn) { this.keyDownListeners.push(fn); },
    onKeyUp: function(fn) { this.keyUpListeners.push(fn); }
};

// ========================================================
// PLAYER CONTROLLER (Slower, accurate, stops in menus)
// ========================================================
WG.Player = {
    yaw: new THREE.Object3D(), pitch: new THREE.Object3D(),
    body: null, canJump: false, radius: 1,
    
    accel: 50,       // Slower acceleration for accuracy
    maxSpeed: 15,    // Lower terminal horizontal velocity
    friction: 0.85,  

    init: function() {
        this.pitch.add(WG.camera);
        this.yaw.position.y = 1;
        this.yaw.add(this.pitch);
        WG.scene.add(this.yaw);

        const shape = new CANNON.Sphere(this.radius);
        this.body = new CANNON.Body({ 
            mass: 60, material: WG.materials.player, 
            fixedRotation: true, linearDamping: 0.1 
        });
        this.body.addShape(shape);
        this.body.position.set(0, 10, 10);
        WG.world.addBody(this.body);

        // Attach collide for player to trigger mod API events
        this.body.addEventListener("collide", (e) => {
            if(WG.Mod.hooks.onCollide) {
                const objB = WG.objects.find(o=>o.body===e.body);
                let tagB = objB ? (objB.opts.modTag || objB.subType || "prop") : 'world';
                WG.Mod.hooks.onCollide('player', tagB);
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement !== document.body) return;
            this.yaw.rotation.y -= e.movementX * 0.002;
            this.pitch.rotation.x -= e.movementY * 0.002;
            this.pitch.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.pitch.rotation.x));
        });

        document.addEventListener('keydown', (e) => this.handleKey(e, true));
        document.addEventListener('keyup', (e) => this.handleKey(e, false));

        document.addEventListener('pointerlockchange', () => {
            if(document.pointerLockElement !== document.body) {
                // If we programmatically unlocked because user pressed U, don't open the menu.
                if(WG._suppressMenuOnUnlock) {
                    WG._suppressMenuOnUnlock = false;
                    return;
                }
                if(!WG.UI.modalsOpen() && WG.isRunning && !WG.Mod.isGameOver && !WG.UI.isConsoleOpen) {
                    WG.UI.toggleQMenu(true);
                }
            } else {
                WG.UI.toggleQMenu(false);
            }
        });
    },

    handleKey: function(e, isDown) {
        if(WG.UI.isConsoleOpen) return; // ignore game keys in console
        const key = e.code.toLowerCase().replace('key', '');
        if(WG.keys.hasOwnProperty(key)) WG.keys[key] = isDown;

        if(isDown && document.pointerLockElement === document.body) {
            if(e.code === 'Space' && this.canJump) {
                this.body.velocity.y = 15; 
                this.canJump = false;
            }
            if(WG.mode === 'sandbox') {
                if(e.code === 'Digit1') WG.Tools.equip('physgun');
                if(e.code === 'Digit2') WG.Tools.equip('portal');
                if(e.code === 'Digit3') WG.Tools.equip('constraint');
            }
        }

        if((e.code === 'KeyQ' || e.code === 'Escape') && !isDown) {
            if (document.pointerLockElement === document.body) {
                document.exitPointerLock(); 
            } else if (WG.UI.isOpen) {
                WG.lockPointer(); 
            }
        }
        
        if(e.code === 'Backquote' && !isDown) { // Tilde/Backquote
            WG.UI.toggleConsole();
        }
    },

    update: function(delta) {
        this.yaw.position.copy(this.body.position);
        this.yaw.position.y += 0.5;

        // Accurate Jump Raycast directly below
        const pos = this.body.position;
        const start = new CANNON.Vec3(pos.x, pos.y - this.radius + 0.12, pos.z);
        // Extend ray further down to reliably detect standing on props/objects
        const end = new CANNON.Vec3(pos.x, pos.y - this.radius - 0.6, pos.z);
        const ray = new CANNON.Ray(start, end);
        
        const hasHit = ray.intersectWorld(WG.world, { mode: CANNON.Ray.CLOSEST });
        this.canJump = (hasHit && ray.result && ray.result.body && ray.result.body !== this.body);

        // Completely stop receiving input if pointer is not locked (e.g., in menu)
        if (document.pointerLockElement !== document.body) {
            if(this.canJump) {
                this.body.velocity.x *= Math.pow(this.friction, delta * 60);
                this.body.velocity.z *= Math.pow(this.friction, delta * 60);
            }
            return;
        }

        const dir = new THREE.Vector3();
        if(WG.keys.w) dir.z -= 1;
        if(WG.keys.s) dir.z += 1;
        if(WG.keys.a) dir.x -= 1;
        if(WG.keys.d) dir.x += 1;

        if(dir.lengthSq() > 0) {
            dir.normalize();
            dir.applyEuler(new THREE.Euler(0, this.yaw.rotation.y, 0));
            
            this.body.velocity.x += dir.x * this.accel * delta;
            this.body.velocity.z += dir.z * this.accel * delta;

            const horiz = new THREE.Vector2(this.body.velocity.x, this.body.velocity.z);
            if(horiz.length() > this.maxSpeed) {
                horiz.normalize().multiplyScalar(this.maxSpeed);
                this.body.velocity.x = horiz.x;
                this.body.velocity.z = horiz.y;
            }
        } else {
            if(this.canJump) { 
                this.body.velocity.x *= Math.pow(this.friction, delta * 60);
                this.body.velocity.z *= Math.pow(this.friction, delta * 60);
            }
        }
    }
};

// ========================================================
// TOOLS (Physgun, Portal, Constraints)
// ========================================================
WG.Tools = {
    active: 'physgun', raycaster: new THREE.Raycaster(),
    heldBody: null, heldDist: 5, heldOffset: new CANNON.Vec3(), marker: null,
    
    // Constraint Tool Data
    cNodeA: null, cPointA: null,

    init: function() {
        const geo = new THREE.SphereGeometry(0.15, 8, 8);
        const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
        this.marker = new THREE.Mesh(geo, mat);
        WG.scene.add(this.marker);
        this.marker.visible = false;

        document.addEventListener('mousedown', (e) => {
            if(document.pointerLockElement !== document.body || WG.mode !== 'sandbox') return;
            if(this.active === 'physgun') this.pgDown(e);
            if(this.active === 'raygun') this.rgFire(e);
            if(this.active === 'portal') WG.Portals.shoot(e);
            if(this.active === 'constraint') this.cnDown(e);
        });
        document.addEventListener('mouseup', (e) => {
            if(this.active === 'physgun' && e.button === 0) this.pgUp();
        });
        document.addEventListener('wheel', (e) => {
            if(document.pointerLockElement !== document.body) return;
            if(this.active === 'physgun' && this.heldBody) {
                this.heldDist -= Math.sign(e.deltaY) * 1.5;
                this.heldDist = Math.max(2, Math.min(this.heldDist, 100));
            }
        });
        document.addEventListener('keydown', (e) => {
            if(document.pointerLockElement !== document.body) return;
            if(e.code === 'KeyE' && this.active === 'physgun') this.pgUnfreeze();
            // expose rotate/throw/unlock handled in WG.Input; keep this for compatibility
        });
    },

    equip: function(tool) {
        if(WG.mode !== 'sandbox') return;
        this.active = tool;
        if(this.heldBody) this.pgUp(); 
        
        const hTool = document.getElementById('hud-tool');
        const hDesc = document.getElementById('hud-desc');
        if(tool === 'physgun') {
            hTool.innerText = "PHYSGUN"; hTool.className = "text-4xl font-extrabold italic text-blue-400 tracking-wider";
            hDesc.innerText = "LMB: Grab | Scroll: Distance | RMB: Freeze | E: Unfreeze";
        } else if (tool === 'portal') {
            hTool.innerText = "PORTALGUN"; hTool.className = "text-4xl font-extrabold italic text-orange-500 tracking-wider";
            hDesc.innerText = "LMB: Blue Portal | RMB: Orange Portal";
        } else if (tool === 'constraint') {
            hTool.innerText = "ANCHOR"; hTool.className = "text-4xl font-extrabold italic text-yellow-400 tracking-wider";
            hDesc.innerText = "LMB: Toggle Anchor (permanent). RMB: Clear Selection";
            this.cNodeA = null;
        } else if (tool === 'raygun') {
            hTool.innerText = "RAY GUN"; hTool.className = "text-4xl font-extrabold italic text-pink-400 tracking-wider";
            hDesc.innerText = "LMB: Fire ray (applies impulse)";
        } else {
            hTool.innerText = ""; hDesc.innerText = "";
        }
    },

    rgFire: function(e) {
        const hits = this.raycastObjects();
        if(hits.length === 0) return;
        const hit = hits[0];
        const obj = WG.objects.find(o => o.mesh === hit.object || (o.mesh.type === 'Group' && o.mesh.children.includes(hit.object)));
        if(!obj || !obj.body) return;
        const dir = new CANNON.Vec3(hit.point.x - WG.camera.position.x, hit.point.y - WG.camera.position.y, hit.point.z - WG.camera.position.z);
        dir.normalize(); dir.scale(60 * (obj.body.mass || 1), dir);
        obj.body.applyImpulse(dir, obj.body.position);
        WG.System.Sound.playSine(600, 0.08, 0.04);
    },

    raycastObjects: function() {
        this.raycaster.setFromCamera({x:0, y:0}, WG.camera);
        const interactables = WG.objects.map(o => o.mesh).filter(m => m !== undefined);
        return this.raycaster.intersectObjects(interactables, true);
    },

    // Physgun logic
    pgDown: function(e) {
        const hits = this.raycastObjects();
        if(hits.length === 0) return;
        const hit = hits[0];
        const obj = WG.objects.find(o => o.mesh === hit.object || (o.mesh.type === 'Group' && o.mesh.children.includes(hit.object)));
        if(!obj) return;

        if(e.button === 0) { 
            if(obj.type === 'static' && obj.body.mass === 0) return;
            
            this.heldBody = obj.body;
            this.heldDist = hit.distance;
            this.marker.visible = true;
            document.getElementById('crosshair').classList.add('active');

            // highlight held object
            this._setHighlight(obj, true);

            if(this.heldBody.type === CANNON.Body.STATIC) {
                this.heldBody.type = CANNON.Body.DYNAMIC;
                this.heldBody.mass = obj.opts ? obj.opts.mass : 5;
                this.heldBody.updateMassProperties();
            }
            
            const hitPoint = new CANNON.Vec3(hit.point.x, hit.point.y, hit.point.z);
            this.heldBody.pointToLocalFrame(hitPoint, this.heldOffset);
        } else if (e.button === 2) { 
            if(this.heldBody) { this.freezeBody(this.heldBody); this.pgUp(); } 
            else if (obj.type !== 'static') this.freezeBody(obj.body);
        }
    },
    pgUp: function() {
        // clear highlight
        if(this.heldBody) {
            const obj = WG.objects.find(o => o.body === this.heldBody);
            if(obj) this._setHighlight(obj, false);
        }
        this.heldBody = null;
        this.marker.visible = false;
        document.getElementById('crosshair').classList.remove('active');
    },
    pgUnfreeze: function() {
        const hits = this.raycastObjects();
        if(hits.length > 0) {
            const obj = WG.objects.find(o => o.mesh === hits[0].object || (o.mesh.type === 'Group' && o.mesh.children.includes(hits[0].object)));
            if(obj && obj.body.type === CANNON.Body.STATIC && obj.type !== 'static') {
                obj.body.type = CANNON.Body.DYNAMIC;
                obj.body.mass = obj.opts ? obj.opts.mass : 5;
                obj.body.updateMassProperties();
                obj.body.wakeUp();
            }
        }
    },
    freezeBody: function(body) {
        body.velocity.set(0,0,0); body.angularVelocity.set(0,0,0);
        body.type = CANNON.Body.STATIC; body.mass = 0; body.updateMassProperties();
    },

    // Constraint Tool Logic
    cnDown: function(e) {
        // Right-click cancels
        if(e.button === 2) {
            this.cNodeA = null;
            WG.Mod.API.print("Anchor selection cleared.", '#fbbf24');
            return;
        }

        const hits = this.raycastObjects();
        if(hits.length === 0) return;
        const hit = hits[0];
        const obj = WG.objects.find(o => o.mesh === hit.object || (o.mesh.type === 'Group' && o.mesh.children.includes(hit.object)));
        if(!obj) return;

        // Toggle anchor state: permanently keep the object in place until toggled again
        if(!obj.opts) obj.opts = {};
        if(obj.opts.anchored) {
            obj.opts.anchored = false;
            // restore to dynamic with original mass
            obj.body.type = CANNON.Body.DYNAMIC;
            obj.body.mass = obj.opts.mass || 5;
            obj.body.updateMassProperties();
            obj.body.wakeUp();
            WG.Mod.API.print('Object unanchored.', '#fb7185');
        } else {
            obj.opts.anchored = true;
            obj.body.velocity.set(0,0,0); obj.body.angularVelocity.set(0,0,0);
            obj.body.type = CANNON.Body.STATIC; obj.body.mass = 0; obj.body.updateMassProperties();
            WG.Mod.API.print('Object anchored permanently.', '#4ade80');
        }
    },

    update: function() {
        if(this.heldBody) {
            const camPos = new THREE.Vector3();
            WG.camera.getWorldPosition(camPos);
            const lookDir = new THREE.Vector3();
            WG.camera.getWorldDirection(lookDir); 

            const targetPos = camPos.add(lookDir.multiplyScalar(this.heldDist));
            this.marker.position.copy(targetPos);

            const worldGripPoint = new CANNON.Vec3();
            this.heldBody.pointToWorldFrame(this.heldOffset, worldGripPoint);

            const forceVec = new CANNON.Vec3(
                targetPos.x - worldGripPoint.x,
                targetPos.y - worldGripPoint.y,
                targetPos.z - worldGripPoint.z
            );
            
            this.heldBody.velocity.set(forceVec.x * 12, forceVec.y * 12, forceVec.z * 12);
            
            const antigrav = WG.world.gravity.scale(-1);
            this.heldBody.force.vadd(antigrav.scale(this.heldBody.mass), this.heldBody.force);
            this.heldBody.angularVelocity.scale(0.8, this.heldBody.angularVelocity); 
        }
    }

    ,

    _setHighlight: function(obj, on) {
        if(!obj || !obj.mesh) return;
        const apply = (mesh, on) => {
            if(!mesh.material) return;
            if(on) {
                if(!mesh.userData._origEmissive) mesh.userData._origEmissive = mesh.material.emissive ? mesh.material.emissive.clone() : new THREE.Color(0x000000);
                if(!mesh.material.emissive) mesh.material.emissive = new THREE.Color(0x00ff00);
                mesh.material.emissive.setHex(0x00ff00);
            } else {
                if(mesh.userData._origEmissive) mesh.material.emissive.copy(mesh.userData._origEmissive);
            }
        };

        if(obj.mesh.type === 'Group') {
            obj.mesh.traverse(m => { if(m.isMesh) apply(m, on); });
        } else if (obj.mesh.isMesh) apply(obj.mesh, on);
    }
};

// ========================================================
// PORTALS SYSTEM (Floor Fixes)
// ========================================================
WG.Portals = {
    blue: null, orange: null, width: 4, height: 6, offset: 0.3, // distance from surface

    init: function() {
        this.rtBlue = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
        this.rtOrange = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
        
        this.camBlue = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camOrange = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        const geo = new THREE.PlaneGeometry(this.width, this.height);
        
        const mB = new THREE.MeshBasicMaterial({ map: this.rtBlue.texture, side: THREE.DoubleSide });
        this.meshBlue = new THREE.Mesh(geo, mB);
        const fb = new THREE.Mesh(new THREE.PlaneGeometry(this.width+0.6, this.height+0.6), new THREE.MeshBasicMaterial({color:0x0088ff}));
        fb.position.z = -0.02; this.meshBlue.add(fb);
        this.meshBlue.visible = false;
        WG.scene.add(this.meshBlue);

        const mO = new THREE.MeshBasicMaterial({ map: this.rtOrange.texture, side: THREE.DoubleSide });
        this.meshOrange = new THREE.Mesh(geo, mO);
        const fo = new THREE.Mesh(new THREE.PlaneGeometry(this.width+0.6, this.height+0.6), new THREE.MeshBasicMaterial({color:0xff8800}));
        fo.position.z = -0.02; this.meshOrange.add(fo);
        this.meshOrange.visible = false;
        WG.scene.add(this.meshOrange);
    },

    resize: function() {
        if(this.rtBlue) {
            this.rtBlue.setSize(window.innerWidth, window.innerHeight);
            this.rtOrange.setSize(window.innerWidth, window.innerHeight);
            this.camBlue.aspect = window.innerWidth / window.innerHeight;
            this.camBlue.updateProjectionMatrix();
            this.camOrange.aspect = window.innerWidth / window.innerHeight;
            this.camOrange.updateProjectionMatrix();
        }
    },

    clear: function() {
        this.meshBlue.visible = false; this.meshOrange.visible = false;
        this.blue = null; this.orange = null;
    },

        shoot: function(e) {
        if(e.button !== 0 && e.button !== 2) return;
        const hits = WG.Tools.raycastObjects();
        if(hits.length === 0) return;
        
        const hit = hits[0];
        const isBlue = e.button === 0;
        
        const obj = WG.objects.find(o => o.mesh === hit.object);
        if(!obj || obj.body.type !== CANNON.Body.STATIC) return; 

        const mesh = isBlue ? this.meshBlue : this.meshOrange;
        // Compute world-space surface normal (faces in mesh local space)
        const normalMatrix = new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld);
        let normal = hit.face.normal.clone().applyMatrix3(normalMatrix).normalize();
        // ensure portal faces the camera: flip if necessary
        const camVec = WG.camera.position.clone().sub(hit.point);
        if(camVec.dot(normal) < 0) normal.negate();
        // place portal slightly off the surface so it's visually flush
        const off = typeof this.offset === 'number' ? this.offset : 0.1;
        mesh.position.copy(hit.point).add(normal.clone().multiplyScalar(off));

        // calculate rotation based on camera pitch snapped to 90Â° increments and build a local portal basis
        const camForward = new THREE.Vector3(); WG.camera.getWorldDirection(camForward);
        const camPitch = Math.asin(camForward.y);
        const snap = Math.round(camPitch / (Math.PI / 2)) * (Math.PI / 2);
        // rotate the world-up vector around the surface normal by the snapped pitch
        let portalUp = new THREE.Vector3(0, 1, 0).clone()
            .applyQuaternion(new THREE.Quaternion().setFromAxisAngle(normal, snap));
        // tangent lies along portal plane perpendicular to normal
        let tangent = new THREE.Vector3().crossVectors(portalUp, normal).normalize();
        const bitangent = normal.clone().cross(tangent).normalize();

        const m = new THREE.Matrix4();
        m.makeBasis(tangent, bitangent, normal);
        mesh.quaternion.setFromRotationMatrix(m);
        mesh.visible = true;

        const pData = { pos: mesh.position.clone(), quat: mesh.quaternion.clone(), normal: normal.clone() };
        if(isBlue) this.blue = pData; else this.orange = pData;
    },

    renderViews: function() {
        if(!this.blue || !this.orange) return;

        const mainCamPos = WG.camera.getWorldPosition(new THREE.Vector3());
        const mainCamQuat = WG.camera.getWorldQuaternion(new THREE.Quaternion());

        const setupCam = (cam, src, dest) => {
            const qSrcInv = src.quat.clone().invert();
            const qY180 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI);
            const qTotal = new THREE.Quaternion().multiplyQuaternions(qY180, dest.quat).multiply(qSrcInv);

            const offset = mainCamPos.clone().sub(src.pos);
            offset.applyQuaternion(qTotal);
            cam.position.copy(dest.pos).add(offset);
            cam.quaternion.copy(mainCamQuat).premultiply(qTotal);
            cam.near = Math.max(0.1, cam.position.distanceTo(dest.pos) * 0.9); 
            cam.updateProjectionMatrix();
        };

        setupCam(this.camBlue, this.blue, this.orange);
        this.meshOrange.visible = false; 
        WG.renderer.setRenderTarget(this.rtBlue);
        WG.renderer.clear();
        WG.renderer.render(WG.scene, this.camBlue);
        this.meshOrange.visible = true;

        setupCam(this.camOrange, this.orange, this.blue);
        this.meshBlue.visible = false;
        WG.renderer.setRenderTarget(this.rtOrange);
        WG.renderer.clear();
        WG.renderer.render(WG.scene, this.camOrange);
        this.meshBlue.visible = true;

        WG.renderer.setRenderTarget(null);
    },

    updatePhysics: function() {
        if(!this.blue || !this.orange) return;
        WG.objects.forEach(obj => {
            if(obj.body.type === CANNON.Body.STATIC) return;
            this.checkCrossing(obj.body, this.blue, this.orange);
            this.checkCrossing(obj.body, this.orange, this.blue);
        });
        this.checkCrossing(WG.Player.body, this.blue, this.orange, true);
        this.checkCrossing(WG.Player.body, this.orange, this.blue, true);
    },

    checkCrossing: function(body, src, dest, isPlayer=false) {
        // box bounds check: convert body position to portal-local coordinates
        // src.pos and body.position are THREE.Vector3 and CANNON.Vec3; normalize both
        const rel = new THREE.Vector3(body.position.x, body.position.y, body.position.z).sub(src.pos);
        let qInv = src.quat.clone().invert();
        rel.applyQuaternion(qInv);
        // very tight bounds: must be nearly centered on portal to cross
        if(Math.abs(rel.x) > this.width/3.5 || Math.abs(rel.y) > this.height/3.5) return;

        const vel = new THREE.Vector3(body.velocity.x, body.velocity.y, body.velocity.z);
        if(vel.lengthSq() < 0.1 && !isPlayer) return;

        vel.normalize();
        if(vel.dot(src.normal) < 0) {
            const qSrcInv = src.quat.clone().invert();
            const qY180 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI);
            const qTotal = new THREE.Quaternion().multiplyQuaternions(qY180, dest.quat).multiply(qSrcInv);

                let posOffset = new THREE.Vector3().copy(body.position).sub(src.pos);
                posOffset.applyQuaternion(qTotal);
                // place at destination with small clearance to avoid re-triggering
                body.position.copy(dest.pos).add(posOffset).add(dest.normal.clone().multiplyScalar(0.1));

                let v = new THREE.Vector3(body.velocity.x, body.velocity.y, body.velocity.z);
                v.applyQuaternion(qTotal);
                body.velocity.set(v.x, v.y, v.z);

                if(!isPlayer) {
                    let q = new THREE.Quaternion(body.quaternion.x, body.quaternion.y, body.quaternion.z, body.quaternion.w);
                    q.premultiply(qTotal);
                    body.quaternion.set(q.x, q.y, q.z, q.w);
                } else {
                    let playerQ = WG.Player.yaw.quaternion.clone();
                    playerQ.premultiply(qTotal);
                    const euler = new THREE.Euler().setFromQuaternion(playerQ, 'YXZ');
                    WG.Player.yaw.rotation.y = euler.y;
                }
            }
        }
};

// ========================================================
// USER INTERFACE
// ========================================================
WG.UI = {
    isOpen: false,
    isConsoleOpen: false,
    
    init: function() {
        document.addEventListener('contextmenu', e => e.preventDefault());
        this.MM.init(); 

        // Load Dark Mode preference
        if(localStorage.getItem('wg_dark_mode') === 'true') {
            this.toggleDarkMode(true);
        }

        const cin = document.getElementById('console-input');
        cin.addEventListener('keydown', (e) => {
            if(e.key === 'Enter') {
                const val = e.target.value;
                WG.Mod.API.print("> " + val, '#aaa');
                try {
                    // Evaluate in global context but provide API mapping visually
                    const API = WG.Mod.API;
                    const res = eval(val);
                    if(res !== undefined) WG.Mod.API.print(res, '#5eead4');
                } catch(err) {
                    WG.Mod.API.print(err.message, '#f87171');
                }
                e.target.value = '';
            }
        });
    },

    toggleQMenu: function(show) {
        this.isOpen = show;
        const menu = document.getElementById('q-menu');
        if(show) {
            document.exitPointerLock();
            menu.classList.remove('hidden');
            this.switchTab('primitives');
        } else {
            menu.classList.add('hidden');
        }
    },

    toggleConsole: function() {
        this.isConsoleOpen = !this.isConsoleOpen;
        const c = document.getElementById('console');
        if(this.isConsoleOpen) {
            document.exitPointerLock();
            c.classList.remove('hidden');
            document.getElementById('console-input').focus();
        } else {
            c.classList.add('hidden');
            WG.lockPointer();
        }
    },

    switchTab: function(tab) {
        const c = document.getElementById('q-content');
        if(tab === 'primitives') {
            c.innerHTML = `
                <h3 class="text-xl font-bold mb-4 border-b border-gray-400 pb-1">Spawn Primitives & Props</h3>
                <div class="grid grid-cols-4 gap-3">
                    <button class="retro-button p-2 flex flex-col items-center" onclick="WG.UI.spawn('box')">
                        <div class="w-10 h-10 bg-blue-500 mb-1 border border-black rounded-sm"></div>
                        <span class="text-[10px]">Cube</span>
                    </button>
                    <button class="retro-button p-2 flex flex-col items-center" onclick="WG.UI.spawn('sphere')">
                        <div class="w-10 h-10 bg-red-500 mb-1 border border-black rounded-full"></div>
                        <span class="text-[10px]">Sphere</span>
                    </button>
                    <button class="retro-button p-2 flex flex-col items-center" onclick="WG.UI.spawn('cylinder')">
                        <div class="w-8 h-10 bg-green-500 mb-1 border border-black rounded-sm"></div>
                        <span class="text-[10px]">Cylinder</span>
                    </button>
                    <button class="retro-button p-2 flex flex-col items-center" onclick="WG.UI.spawnSpecial('bouncy')">
                        <span class="text-2xl mb-1">ðŸŸ¢</span>
                        <span class="text-[10px]">Bouncy Ball</span>
                    </button>
                    <button class="retro-button p-2 flex flex-col items-center" onclick="WG.UI.spawnSpecial('heavy')">
                        <span class="text-2xl mb-1">ðŸª¨</span>
                        <span class="text-[10px]">Heavy Crate</span>
                    </button>
                    <button class="retro-button p-2 flex flex-col items-center" onclick="WG.UI.spawnSpecial('plank')">
                        <span class="text-2xl mb-1">ðŸªµ</span>
                        <span class="text-[10px]">Plank</span>
                    </button>
                    <button class="retro-button p-2 flex flex-col items-center" onclick="WG.UI.spawnSpecial('thruster')">
                        <span class="text-2xl mb-1">ðŸ”¥</span>
                        <span class="text-[10px]">Thruster (T)</span>
                    </button>
                    <button class="retro-button p-2 flex flex-col items-center" onclick="WG.UI.spawnSpecial('balloon')">
                        <span class="text-2xl mb-1">ðŸŽˆ</span>
                        <span class="text-[10px]">Balloon</span>
                    </button>
                </div>
            `;
        } else if (tab === 'custom') {
            let html = `<h3 class="text-xl font-bold mb-4 border-b border-gray-400 pb-1">Custom Library</h3>
            <div class="flex gap-2 mb-4">
                <button class="retro-button py-2 px-3 text-sm" onclick="WG.UI.exportModels()">Export Models (JSON)</button>
                <button class="retro-button py-2 px-3 text-sm" onclick="WG.UI.importModels()">Import Models (JSON)</button>
            </div>
            <div class="grid grid-cols-4 gap-3">`;
            const keys = Object.keys(WG.customModels);
            if(keys.length === 0) {
                html += `<div class="col-span-4 text-center mt-10">Library is empty. Create models in the Model Maker!</div>`;
            } else {
                keys.forEach(k => {
                    html += `
                    <button class="retro-button p-2 flex flex-col items-center" onclick="WG.UI.spawnCustom('${k}')">
                        <span class="text-2xl mb-1">ðŸ“¦</span>
                        <span class="text-xs truncate w-full text-center">${k}</span>
                    </button>`;
                });
            }
            c.innerHTML = html + '</div>';
        } else if (tab === 'settings') {
            c.innerHTML = `
                <h3 class="text-xl font-bold mb-4 border-b border-gray-400 pb-1">World Settings</h3>
                <div class="space-y-4 max-w-sm">
                    <div class="flex flex-col">
                        <label class="text-sm font-bold">Gravity (Y Axis)</label>
                        <input type="number" id="set-grav" value="${WG.gravity}" class="retro-inset px-2 py-1">
                    </div>
                    <div class="flex flex-col">
                        <label class="text-sm font-bold">Atmosphere Color</label>
                        <input type="color" id="set-sky" value="#7ec0ee" class="h-10 w-full cursor-pointer">
                    </div>
                    <div class="flex flex-col">
                        <label class="text-sm font-bold">UI Theme</label>
                        <div class="flex gap-2">
                            <button class="retro-button py-2 px-3" onclick="WG.UI.toggleDarkMode(true)">Dark Mode</button>
                            <button class="retro-button py-2 px-3" onclick="WG.UI.toggleDarkMode(false)">Light Mode</button>
                        </div>
                    </div>
                    <button class="retro-button py-2 w-full mt-4" onclick="WG.UI.applySettings()">Apply Settings</button>
                </div>
            `;
        }
    },

    applySettings: function() {
        const grav = parseFloat(document.getElementById('set-grav').value);
        const sky = document.getElementById('set-sky').value;
        WG.world.gravity.set(0, grav, 0);
        WG.gravity = grav;
        WG.scene.background = new THREE.Color(sky);
        WG.scene.fog.color = new THREE.Color(sky);
        WG.Mod.API.print("Settings Applied.", '#4ade80');
    },

    toggleDarkMode: function(enable) {
        if(enable) document.body.classList.add('wg-dark');
        else document.body.classList.remove('wg-dark');
        
        localStorage.setItem('wg_dark_mode', enable);

        const style = document.getElementById('wg-dark-style') || document.createElement('style');
        style.id = 'wg-dark-style';
        
        if (enable) {
            style.innerHTML = `
                body.wg-dark { background-color: #121212; color: #e0e0e0; }
                
                /* Panels & Windows */
                body.wg-dark .retro-panel { 
                    background-color: #2d2d2d !important; 
                    border-top-color: #4a4a4a !important; 
                    border-left-color: #4a4a4a !important; 
                    border-bottom-color: #1a1a1a !important; 
                    border-right-color: #1a1a1a !important; 
                    color: #e0e0e0 !important; 
                }
                
                /* Insets (Content Areas) */
                body.wg-dark .retro-inset { 
                    background-color: #1a1a1a !important; 
                    border-top-color: #000 !important; 
                    border-left-color: #000 !important; 
                    border-bottom-color: #4a4a4a !important; 
                    border-right-color: #4a4a4a !important;
                    color: #e0e0e0 !important;
                }
                
                /* Buttons */
                body.wg-dark .retro-button { 
                    background-color: #3d3d3d !important; 
                    border-top-color: #5a5a5a !important; 
                    border-left-color: #5a5a5a !important; 
                    border-bottom-color: #1a1a1a !important; 
                    border-right-color: #1a1a1a !important; 
                    color: #fff !important; 
                }
                body.wg-dark .retro-button:active {
                    border-top-color: #1a1a1a !important; 
                    border-left-color: #1a1a1a !important; 
                    border-bottom-color: #5a5a5a !important; 
                    border-right-color: #5a5a5a !important;
                }
                
                /* Inputs */
                body.wg-dark input, body.wg-dark select, body.wg-dark textarea {
                    background-color: #1a1a1a !important;
                    color: #fff !important;
                    border: 1px solid #4a4a4a !important;
                }
                
                /* Scrollbars */
                body.wg-dark ::-webkit-scrollbar-track { background: #2d2d2d; border-left: 1px solid #444; }
                body.wg-dark ::-webkit-scrollbar-thumb { background: #555; border: 1px solid #2d2d2d; }
                
                /* Tailwind Overrides for Hardcoded Colors */
                body.wg-dark .bg-gray-100 { background-color: #1a1a1a !important; }
                body.wg-dark .bg-\\[\\#d4d0c8\\] { background-color: #2d2d2d !important; }
                body.wg-dark .text-black { color: #e0e0e0 !important; }
                body.wg-dark .text-gray-800 { color: #ccc !important; }
                body.wg-dark .text-gray-600 { color: #aaa !important; }
                body.wg-dark .bg-white { background-color: #222 !important; color: #eee !important; border-color: #444 !important; }
                
                /* Title Bar */
                body.wg-dark .retro-title {
                    background: linear-gradient(90deg, #3700b3, #6200ea) !important;
                }
            `;
        } else {
            style.innerHTML = '';
        }
        
        if (!document.getElementById('wg-dark-style')) document.head.appendChild(style);
    },

    exportModels: function() {
        const json = JSON.stringify(WG.customModels);
        const blob = new Blob([json], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'models.json';
        a.click();
        URL.revokeObjectURL(url);
        WG.Mod.API.print('Models exported as JSON', '#4ade80');
    },

    importModels: function() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = e => {
            const reader = new FileReader();
            reader.onload = ev => {
                try {
                    const loaded = JSON.parse(ev.target.result);
                    Object.assign(WG.customModels, loaded);
                    WG.Data.saveModel('bulk_import', loaded);
                    WG.UI.switchTab('custom');
                    WG.Mod.API.print('Models imported successfully', '#4ade80');
                } catch(err) { 
                    alert('Invalid JSON file: ' + err.message); 
                }
            };
            reader.readAsText(e.target.files[0]);
        };
        input.click();
    },

    // Material Editor helpers
    matSelectionId: null,
    openMaterialEditor: function() { document.getElementById('material-editor').classList.remove('hidden'); document.getElementById('mat-selected').innerText = this.matSelectionId || 'none'; },
    applyMaterialToSelection: function() {
        const id = this.matSelectionId;
        const color = document.getElementById('mat-color').value;
        if(!id) return alert('No object selected');
        const obj = WG.objects.find(o => o.id === id);
        if(!obj) return alert('Object not found');
        const apply = (m) => { if(m.material) { m.material.color = new THREE.Color(color); m.material.needsUpdate = true; } };
        if(obj.mesh.type === 'Group') obj.mesh.traverse(m => { if(m.isMesh) apply(m); }); else if(obj.mesh.isMesh) apply(obj.mesh);
        WG.Mod.API.print('Material applied to ' + id, '#93c5fd');
    },
    selectMaterialFromPointer: function() {
        const hits = WG.Tools.raycastObjects();
        if(hits.length === 0) return alert('No object under pointer');
        const hit = hits[0];
        const obj = WG.objects.find(o => o.mesh === hit.object || (o.mesh.type === 'Group' && o.mesh.children.includes(hit.object)));
        if(!obj) return alert('No object match');
        this.matSelectionId = obj.id; document.getElementById('mat-selected').innerText = obj.id;
    },

    getSpawnPos: function() {
        const camPos = new THREE.Vector3();
        WG.camera.getWorldPosition(camPos);
        const lookDir = new THREE.Vector3();
        WG.camera.getWorldDirection(lookDir); 
        return camPos.add(lookDir.multiplyScalar(8));
    },

    spawn: function(type) {
        const pos = this.getSpawnPos();
        WG.spawnPrimitive(type, pos.x, pos.y, pos.z);
        this.toggleQMenu(false);
        WG.lockPointer();
    },

    spawnSpecial: function(special) {
        const pos = this.getSpawnPos();
        if(special === 'bouncy') WG.spawnPrimitive('sphere', pos.x, pos.y, pos.z, { size: [3], bouncy: true, mass: 2, color: '#00ffaa' });
        if(special === 'heavy') WG.spawnPrimitive('box', pos.x, pos.y, pos.z, { size: [4,4,4], mass: 100, color: '#444444' });
        if(special === 'plank') WG.spawnPrimitive('box', pos.x, pos.y, pos.z, { size: [15, 0.5, 3], mass: 5, color: '#c19a6b' });
        if(special === 'thruster') WG.spawnPrimitive('cylinder', pos.x, pos.y, pos.z, { size: [2, 4], mass: 2, color: '#ffaa00', isThruster: true });
        if(special === 'balloon') WG.spawnPrimitive('sphere', pos.x, pos.y, pos.z, { size: [4], mass: 0.5, color: '#ff66b2', isBalloon: true });

        this.toggleQMenu(false);
        WG.lockPointer();
    },

    spawnCustom: function(name) {
        const pos = this.getSpawnPos();
        WG.spawnCustomModel(name, pos.x, pos.y, pos.z);
        this.toggleQMenu(false);
        WG.lockPointer();
    },

    modalsOpen: function() {
        return !document.getElementById('model-maker').classList.contains('hidden') || 
               !document.getElementById('mod-creator').classList.contains('hidden');
    },

    hideAll: function() {
        this.toggleQMenu(false);
        this.closeModals();
        if(this.isConsoleOpen) this.toggleConsole();
    },

    openModelMaker: function() { document.getElementById('model-maker').classList.remove('hidden'); this.MM.isOpen = true; this.MM.rebuildPreview(); },
    openModCreator: function() { document.getElementById('mod-creator').classList.remove('hidden'); },
    closeModals: function() {
        document.getElementById('model-maker').classList.add('hidden');
        document.getElementById('mod-creator').classList.add('hidden');
        this.MM.isOpen = false;
    },

    // Visual Model Maker
    MM: {
        parts: [], isOpen: false,
        scene: null, camera: null, renderer: null, group: null,

        init: function() {
            const canvas = document.getElementById('mm-canvas');
            this.renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x333333);
            
            this.camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            this.camera.position.set(10, 10, 10);
            this.camera.lookAt(0,0,0);

            this.scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const light = new THREE.DirectionalLight(0xffffff, 0.8);
            light.position.set(10, 20, 10);
            this.scene.add(light);
            this.scene.add(new THREE.GridHelper(20, 20, 0x555555, 0x444444));

            this.group = new THREE.Group();
            this.scene.add(this.group);
        },

        renderPreview: function() {
            if(!this.isOpen) return;
            const canvas = this.renderer.domElement;
            const parent = canvas.parentElement;
            if(canvas.width !== parent.clientWidth || canvas.height !== parent.clientHeight) {
                this.renderer.setSize(parent.clientWidth, parent.clientHeight, false);
                this.camera.aspect = parent.clientWidth / parent.clientHeight;
                this.camera.updateProjectionMatrix();
            }
            this.group.rotation.y += 0.01;
            this.renderer.render(this.scene, this.camera);
        },

        rebuildPreview: function() {
            while(this.group.children.length > 0) this.group.remove(this.group.children[0]); 
            const isBouncy = document.getElementById('mm-bouncy').checked;
            this.parts.forEach(part => {
                let sz = part.size.map(Number); let off = part.offset.map(Number);
                let geo = part.type === 'box' ? new THREE.BoxGeometry(sz[0], sz[1], sz[2]) : new THREE.SphereGeometry(sz[0]/2, 16, 16);
                let mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: part.color, roughness: isBouncy?0.2:0.7 }));
                mesh.position.set(off[0], off[1], off[2]);
                this.group.add(mesh);
            });
        },

        addPart: function() {
            this.parts.push({ type: 'box', size: [2,2,2], offset: [0,0,0], color: '#ffffff' });
            this.renderUI(); this.rebuildPreview();
        },

        renderUI: function() {
            const c = document.getElementById('mm-parts');
            c.innerHTML = '';
            this.parts.forEach((p, i) => {
                c.innerHTML += `
                <div class="bg-white p-2 flex items-center space-x-2 border border-gray-400">
                    <select class="retro-inset p-1 text-xs w-20" onchange="WG.UI.MM.upd(${i}, 'type', this.value)">
                        <option value="box" ${p.type==='box'?'selected':''}>Box</option>
                        <option value="sphere" ${p.type==='sphere'?'selected':''}>Sphere</option>
                    </select>
                    <div class="flex flex-col space-y-1 flex-1 text-xs">
                        <div class="flex items-center space-x-1"><span class="w-8">Size</span><input type="text" value="${p.size.join(',')}" class="w-full retro-inset px-1" onchange="WG.UI.MM.upd(${i}, 'size', this.value.split(','))"></div>
                        <div class="flex items-center space-x-1"><span class="w-8">Pos</span><input type="text" value="${p.offset.join(',')}" class="w-full retro-inset px-1" onchange="WG.UI.MM.upd(${i}, 'offset', this.value.split(','))"></div>
                    </div>
                    <input type="color" value="${p.color}" onchange="WG.UI.MM.upd(${i}, 'color', this.value)" class="h-6 w-6 cursor-pointer">
                    <button class="retro-button w-6 h-6 text-red-700 leading-none pb-1" onclick="WG.UI.MM.rem(${i})">X</button>
                </div>`;
            });
        },
        upd: function(i, k, v) { this.parts[i][k] = v; this.rebuildPreview(); },
        rem: function(i) { this.parts.splice(i, 1); this.renderUI(); this.rebuildPreview(); },
        save: function() {
            const name = document.getElementById('mm-name').value.trim() || "Prop_" + Math.floor(Math.random()*1000);
            if(this.parts.length === 0) return alert("Need at least 1 part!");
            WG.customModels[name] = { 
                name: name, parts: JSON.parse(JSON.stringify(this.parts)),
                bouncy: document.getElementById('mm-bouncy').checked, mass: parseFloat(document.getElementById('mm-mass').value) || 5
            };
            WG.Data.saveModel(name, WG.customModels[name]);
            alert("Model Saved.");
            WG.UI.closeModals();
            WG.UI.switchTab('custom');
        }
    }
};

// ========================================================
// MOD API & EXAMPLES 
// ========================================================
WG.Mod = {
    hooks: { onTick: [] },
    currency: 0,
    isGameOver: false,
    savedScripts: [],
    
    init: function() {
        // Collisions handled per body in spawnPrimitive now.
    },

    API: {
        spawn: (t, x, y, z, opts) => WG.spawnPrimitive(t, x, y, z, opts),
        onTick: (fn) => WG.Mod.hooks.onTick.push(fn),
        onCollide: (fn) => WG.Mod.hooks.onCollide = fn,
        getPlayerPos: () => ({x: WG.Player.body.position.x, y: WG.Player.body.position.y, z: WG.Player.body.position.z}),
        
        // Game State APIs
        setCurrency: (val) => { 
            WG.Mod.currency = val; 
            document.getElementById('currency-ui').classList.remove('hidden');
            document.getElementById('currency-val').innerText = val;
        },
        addCurrency: (val) => { 
            WG.Mod.currency += val; 
            document.getElementById('currency-val').innerText = WG.Mod.currency;
        },
        gameOver: (msg) => {
            WG.Mod.isGameOver = true;
            document.exitPointerLock();
            document.getElementById('game-over-ui').classList.remove('hidden');
            document.getElementById('game-over-msg').innerText = msg || "You Lose!";
        },
        print: (msg, color='#fff') => {
            const log = document.getElementById('console-output');
            const span = document.createElement('div');
            span.style.color = color;
            span.innerText = typeof msg === 'object' ? JSON.stringify(msg) : msg;
            log.appendChild(span);
            log.scrollTop = log.scrollHeight;
        },
        // Dynamic UI 
        createButton: (id, text, x, y, onClick) => {
            const container = document.getElementById('dynamic-ui');
            let el = document.getElementById(id);
            if(el) el.remove();
            el = document.createElement('button');
            el.id = id; el.className = 'dyn-element retro-button px-4 py-2';
            el.style.left = x + 'px'; el.style.top = y + 'px';
            el.innerText = text; el.onclick = onClick;
            container.appendChild(el);
        },
        createText: (id, text, x, y, color) => {
            const container = document.getElementById('dynamic-ui');
            let el = document.getElementById(id);
            if(el) el.remove();
            el = document.createElement('div');
            el.id = id; el.className = 'dyn-element font-bold font-mono text-xl drop-shadow-md';
            el.style.color = color || 'white';
            el.style.left = x + 'px'; el.style.top = y + 'px';
            el.innerText = text;
            container.appendChild(el);
        },
        clearUI: () => {
            document.getElementById('dynamic-ui').innerHTML = '';
        }
        ,
        // Key event hooks for mods
        onKeyDown: (fn) => { WG.Input.onKeyDown(fn); },
        onKeyUp: (fn) => { WG.Input.onKeyUp(fn); },
        // Permanently freeze an object by id (or body) so it never simulates until unfrozen
        freezePermanent: (idOrBody) => {
            let obj = null;
            if(typeof idOrBody === 'string') obj = WG.objects.find(o => o.id === idOrBody);
            else obj = WG.objects.find(o => o.body === idOrBody) || WG.objects.find(o => o === idOrBody);
            if(!obj) return false;
            obj.opts.permanentFrozen = true;
            obj.body.velocity.set(0,0,0); obj.body.angularVelocity.set(0,0,0);
            obj.body.type = CANNON.Body.STATIC; obj.body.mass = 0; obj.body.updateMassProperties();
            return true;
        },
        // World controls
        setGravity: (val) => { WG.world.gravity.set(0, val, 0); WG.gravity = val; },
        // Export a single model (primitive or custom) as JSON
        exportModel: (id) => {
            const obj = WG.objects.find(o => o.id === id);
            if(!obj) return null;
            const out = { id: obj.id, type: obj.type, subType: obj.subType, modelName: obj.modelName, opts: obj.opts };
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(out, null, 2));
            const a = document.createElement('a'); a.href = dataStr; a.download = (obj.modelName||obj.subType||'model') + '.json'; a.click();
            return out;
        },
        // Import OBJ file (File object) into custom models and save to DB
        importOBJ: (file, name) => {
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const loader = new THREE.OBJLoader();
                    const obj = loader.parse(ev.target.result);
                    // Simple conversion: store geometry chunk list and material color
                    const parts = [];
                    obj.traverse((m) => {
                        if(m.isMesh) {
                            const bbox = new THREE.Box3().setFromObject(m);
                            const size = bbox.getSize(new THREE.Vector3());
                            parts.push({ type: 'box', size: [size.x, size.y, size.z], offset: [m.position.x, m.position.y, m.position.z], color: (m.material && m.material.color)? '#' + m.material.color.getHexString() : '#ffffff' });
                        }
                    });
                    const modelName = name || (file.name ? file.name.replace(/\.obj$/i,'') : 'imported');
                    WG.customModels[modelName] = { name: modelName, parts: parts, bouncy: false, mass: 5 };
                    WG.Data.saveModel(modelName, WG.customModels[modelName]);
                    WG.Mod.API.print('OBJ imported as model: ' + modelName, '#4ade80');
                } catch(err) { WG.Mod.API.print('OBJ import failed: ' + err.message, '#f87171'); }
            };
            reader.readAsText(file);
        }
    },

    loadExample: function(type) {
        const ta = document.getElementById('mod-code');
        if(type === 'minigame') {
            ta.value = `// Mini-Game: Dodge the Anvil!
API.setCurrency(0);

let timer = 0;
API.onTick((delta) => {
    timer += delta;
    if(timer > 1.5) { 
        let pos = API.getPlayerPos();
        API.addCurrency(10); 
        API.spawn('box', pos.x, pos.y + 40, pos.z, { 
            size: [4,4,4], color: 0xff0000, mass: 200, modTag: 'danger' 
        });
        timer = 0;
    }
});

API.onCollide((a, b) => {
    if((a === 'player' && b === 'danger') || (b === 'player' && a === 'danger')) {
        API.gameOver("SQUISHED! Final Score: " + document.getElementById('currency-val').innerText);
    }
});`;
        } else if (type === 'clicker') {
            ta.value = `// Coin Collector
API.setCurrency(0);

for(let i=0; i<10; i++) {
    API.spawn('cylinder', Math.random()*50-25, 2, Math.random()*50-25, { 
        size: [2, 0.5], color: 0xffd700, mass: 1, bouncy: true, modTag: 'coin'
    });
}

API.onCollide((a, b) => {
    if(a === 'player' && b === 'coin' || b === 'player' && a === 'coin') {
        API.addCurrency(1);
        // Note: For simplicity, we just look for coin count.
        // You'd normally delete the coin object via custom engine loops.
        if(document.getElementById('currency-val').innerText == "10") {
            API.gameOver("ALL COINS COLLECTED!");
        }
    }
});`;
        } else if (type === 'ui') {
            ta.value = `// Dynamic UI & Interactions
API.clearUI();

API.createText('mytext', 'Welcome to the Moon', 20, 100, '#00ffff');

API.createButton('mybtn', 'Toggle Low Gravity', 20, 140, () => {
    API.print("Gravity changed!");
    if(WG.world.gravity.y === -25) {
        API.setGravity(-4);
    } else {
        API.setGravity(-25);
    }
});`;
        }
    },

    execute: function() {
        this.clear();
        const code = document.getElementById('mod-code').value;
        this.savedScripts.push(code);
        try {
            const fn = new Function('API', code);
            fn(this.API);
            this.API.print("Script Injected Successfully!", '#4ade80');
            WG.UI.closeModals();
            WG.lockPointer();
        } catch(e) {
            alert("Script Compile Error:\n" + e.message);
        }
    },
    
    clear: function() {
        this.hooks.onTick = [];
        this.hooks.onCollide = null;
        this.isGameOver = false;
        this.savedScripts = [];
        document.getElementById('currency-ui').classList.add('hidden');
        document.getElementById('game-over-ui').classList.add('hidden');
        this.API.clearUI();
    },

    exportScript: function() {
        const code = document.getElementById('mod-code').value;
        const blob = new Blob([code], {type: 'text/javascript'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'mod_script.js';
        a.click();
        URL.revokeObjectURL(url);
        this.API.print('Script exported as .js file', '#4ade80');
    },

    importScript: function() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.js';
        input.onchange = e => {
            const reader = new FileReader();
            reader.onload = ev => {
                try {
                    const code = ev.target.result;
                    document.getElementById('mod-code').value = code;
                    this.API.print('Script imported successfully', '#4ade80');
                } catch(err) { 
                    alert('Error reading file: ' + err.message); 
                }
            };
            reader.readAsText(e.target.files[0]);
        };
        input.click();
    },

    resetGame: function() {
        this.isGameOver = false;
        document.getElementById('game-over-ui').classList.add('hidden');
        WG.clearWorld();
        WG.buildBlank();
        
        // Re-execute saved scripts
        let tempScripts = [...this.savedScripts];
        this.clear(); // clears savedScripts too
        tempScripts.forEach(script => {
            this.savedScripts.push(script);
            try { const fn = new Function('API', script); fn(this.API); } catch(e){}
        });
        
        WG.lockPointer();
    },

    update: function(delta) {
        this.hooks.onTick.forEach(fn => { try { fn(delta); } catch(e){} });
    }
};

// ========================================================
// DATA PERSISTENCE (Exports scripts & mode toggles)
// ========================================================
// System utilities: sound, explosives, time scaling, and helpers
WG.System = {
    Sound: {
        // stub - audio context and simple play function
        ctx: null,
        init: function() { try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { this.ctx = null; } },
        playSine: function(freq, duration=0.2, vol=0.1) {
            if(!this.ctx) { WG.Mod.API.print('Audio unavailable', '#f59e0b'); return; }
            const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
            o.type = 'sine'; o.frequency.value = freq; g.gain.value = vol;
            o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime + duration);
        }
    },
    Explosives: {
        spawn: function(x,y,z, opts={radius:8,force:200}) {
            const e = WG.spawnPrimitive('sphere', x,y,z, { size: [1], mass: 1, color: '#ff3300' });
            // blast nearby
            WG.objects.forEach(o => {
                if(!o.body || o.body.type === CANNON.Body.STATIC) return;
                const d = o.body.position.distanceTo(new CANNON.Vec3(x,y,z));
                if(d < opts.radius) {
                    const dir = new CANNON.Vec3(o.body.position.x - x, o.body.position.y - y, o.body.position.z - z);
                    dir.normalize(); dir.scale(opts.force * (1 - d/opts.radius), dir);
                    o.body.applyImpulse(dir, o.body.position);
                }
            });
        }
    },
    Time: {
        setScale: function(s) { WG.timeScale = Math.max(0, Math.min(5, s)); }
    }
};

// Mod script helper functions
WG.Mod.saveScript = function(name, code) { WG.Data.savedScripts = WG.Data.savedScripts || {}; WG.Data.savedScripts[name] = code; WG.Mod.API.print('Script saved: '+name, '#93c5fd'); };
WG.Mod.loadScript = function(name) { return (WG.Data.savedScripts && WG.Data.savedScripts[name]) || null; };
WG.Data = {
    db: null, importedState: null,
    
    initDB: function() {
        return new Promise((resolve) => {
            const req = indexedDB.open("PhysicsEngineDB", 1);
            req.onupgradeneeded = e => {
                let db = e.target.result;
                if(!db.objectStoreNames.contains('models')) db.createObjectStore('models');
            };
            req.onsuccess = e => { this.db = e.target.result; resolve(); };
            req.onerror = () => resolve(); 
        });
    },

    saveModel: function(name, data) {
        if(!this.db) return;
        const tx = this.db.transaction('models', 'readwrite');
        tx.objectStore('models').put(data, name);
    },

    loadCustomModels: function() {
        return new Promise(resolve => {
            if(!this.db) return resolve();
            const tx = this.db.transaction('models', 'readonly');
            const req = tx.objectStore('models').getAllKeys();
            req.onsuccess = () => {
                const keys = req.result;
                let loaded = 0;
                if(keys.length === 0) resolve();
                keys.forEach(k => {
                    const getReq = tx.objectStore('models').get(k);
                    getReq.onsuccess = e => {
                        WG.customModels[k] = e.target.result;
                        loaded++;
                        if(loaded === keys.length) resolve();
                    };
                });
            };
        });
    },

    serialize: function() {
        const state = { objects: [], scripts: WG.Mod.savedScripts, gravity: WG.gravity, background: WG.scene.background ? WG.scene.background.getHex() : 0x7ec0ee, fogDensity: (WG.scene.fog && WG.scene.fog.density) ? WG.scene.fog.density : null, models: WG.customModels };
        if(WG.Portals && WG.Portals.blue) state.portalBlue = { pos: [WG.Portals.blue.pos.x, WG.Portals.blue.pos.y, WG.Portals.blue.pos.z], quat: [WG.Portals.blue.quat.x, WG.Portals.blue.quat.y, WG.Portals.blue.quat.z, WG.Portals.blue.quat.w], normal: [WG.Portals.blue.normal.x, WG.Portals.blue.normal.y, WG.Portals.blue.normal.z] };
        if(WG.Portals && WG.Portals.orange) state.portalOrange = { pos: [WG.Portals.orange.pos.x, WG.Portals.orange.pos.y, WG.Portals.orange.pos.z], quat: [WG.Portals.orange.quat.x, WG.Portals.orange.quat.y, WG.Portals.orange.quat.z, WG.Portals.orange.quat.w], normal: [WG.Portals.orange.normal.x, WG.Portals.orange.normal.y, WG.Portals.orange.normal.z] };
        WG.objects.forEach(obj => {
            if(obj.opts && obj.opts.isGround) return; 
            if(obj.type === 'static' || !obj.body) return; 
            state.objects.push({
                type: obj.type, subType: obj.subType, modelName: obj.modelName,
                opts: obj.opts,
                pos: [obj.body.position.x, obj.body.position.y, obj.body.position.z],
                quat: [obj.body.quaternion.x, obj.body.quaternion.y, obj.body.quaternion.z, obj.body.quaternion.w]
            });
        });
        return state;
    },

    deserialize: function(state) {
        WG.buildBlank(); 
        // restore custom models if present
        if(state.models) WG.customModels = Object.assign({}, WG.customModels, state.models);
        state.objects.forEach(data => {
            if(data.type === 'primitive') {
                WG.spawnPrimitive(data.subType, data.pos[0], data.pos[1], data.pos[2], Object.assign({}, data.opts, {rotation: data.quat}));
            } else if (data.type === 'custom') {
                WG.spawnCustomModel(data.modelName, data.pos[0], data.pos[1], data.pos[2], data.quat);
            }
        });

        // restore portals if included
        if(state.portalBlue) {
            WG.Portals.blue = { pos: new THREE.Vector3(state.portalBlue.pos[0], state.portalBlue.pos[1], state.portalBlue.pos[2]), quat: new THREE.Quaternion(state.portalBlue.quat[0], state.portalBlue.quat[1], state.portalBlue.quat[2], state.portalBlue.quat[3]), normal: new THREE.Vector3(state.portalBlue.normal[0], state.portalBlue.normal[1], state.portalBlue.normal[2]) };
            WG.Portals.meshBlue.position.copy(WG.Portals.blue.pos); WG.Portals.meshBlue.quaternion.copy(WG.Portals.blue.quat); WG.Portals.meshBlue.visible = true;
        }
        if(state.portalOrange) {
            WG.Portals.orange = { pos: new THREE.Vector3(state.portalOrange.pos[0], state.portalOrange.pos[1], state.portalOrange.pos[2]), quat: new THREE.Quaternion(state.portalOrange.quat[0], state.portalOrange.quat[1], state.portalOrange.quat[2], state.portalOrange.quat[3]), normal: new THREE.Vector3(state.portalOrange.normal[0], state.portalOrange.normal[1], state.portalOrange.normal[2]) };
            WG.Portals.meshOrange.position.copy(WG.Portals.orange.pos); WG.Portals.meshOrange.quaternion.copy(WG.Portals.orange.quat); WG.Portals.meshOrange.visible = true;
        }

        // Run imported scripts
        if(state.scripts) {
            WG.Mod.clear();
            state.scripts.forEach(script => {
                WG.Mod.savedScripts.push(script);
                try { const fn = new Function('API', script); fn(WG.Mod.API); } catch(e){}
            });
        }
    },

    exportFile: function() {
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.serialize()));
        const a = document.createElement('a');
        a.href = dataStr;
        a.download = "physics_world.json";
        a.click();
    },

    importFile: function() {
        const input = document.createElement('input');
        input.type = 'file'; input.accept = '.json';
        input.onchange = e => {
            const reader = new FileReader();
            reader.onload = ev => {
                try {
                    this.importedState = JSON.parse(ev.target.result);
                    document.getElementById('launch-screen').classList.add('hidden');
                    document.getElementById('import-mode-screen').classList.remove('hidden');
                } catch(err) { alert("Corrupt Save File."); }
            };
            reader.readAsText(e.target.files[0]);
        };
        input.click();
    },

    resumeImport: function(mode) {
        document.getElementById('import-mode-screen').classList.add('hidden');
        if(this.importedState) {
            WG.launch('blank', mode);
            setTimeout(() => {
                this.deserialize(this.importedState);
                this.importedState = null;
            }, 100);
        }
    },

    clearAll: async function() {
        if(!confirm('Delete all saved models and data? This cannot be undone.')) return;
        
        if(!this.db) await this.initDB();

        // Clear IndexedDB
        if(this.db) {
            const tx = this.db.transaction('models', 'readwrite');
            tx.objectStore('models').clear();
        }
        // Clear in-memory models
        WG.customModels = {};
        if(WG.Mod && WG.Mod.API) WG.Mod.API.print('All saved data cleared', '#4ade80');
        alert('Saved data cleared!');
    }
};

// ensure launch buttons respond even if inline handlers fail
(function(){
    const b1 = document.getElementById('launch-blank');
    const b2 = document.getElementById('launch-demo');
    if(b1) b1.addEventListener('click', () => {
        console.log('blank button clicked');
        if(window.WG && WG.tryLaunch) WG.tryLaunch('blank');
        else console.warn('WG not ready for blank launch');
    });
    if(b2) b2.addEventListener('click', () => {
        console.log('demo button clicked');
        if(window.WG && WG.tryLaunch) WG.tryLaunch('premade');
        else console.warn('WG not ready for demo launch');
    });
    document.addEventListener('click', e => { console.log('global click', e.target); });
})();
</script>
</body>
</html>
